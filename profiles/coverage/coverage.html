
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Vidkin/metrics/app/server.go (0.0%)</option>
				
				<option value="file1">github.com/Vidkin/metrics/cmd/agent/main.go (0.0%)</option>
				
				<option value="file2">github.com/Vidkin/metrics/cmd/server/main.go (0.0%)</option>
				
				<option value="file3">github.com/Vidkin/metrics/internal/agent/worker.go (56.7%)</option>
				
				<option value="file4">github.com/Vidkin/metrics/internal/config/agent_config.go (0.0%)</option>
				
				<option value="file5">github.com/Vidkin/metrics/internal/config/server_address.go (0.0%)</option>
				
				<option value="file6">github.com/Vidkin/metrics/internal/config/server_config.go (0.0%)</option>
				
				<option value="file7">github.com/Vidkin/metrics/internal/logger/logger.go (0.0%)</option>
				
				<option value="file8">github.com/Vidkin/metrics/internal/metric/metric.go (100.0%)</option>
				
				<option value="file9">github.com/Vidkin/metrics/internal/repository/mock/mock_repository.go (61.8%)</option>
				
				<option value="file10">github.com/Vidkin/metrics/internal/repository/storage/file.go (15.3%)</option>
				
				<option value="file11">github.com/Vidkin/metrics/internal/repository/storage/memory.go (86.2%)</option>
				
				<option value="file12">github.com/Vidkin/metrics/internal/repository/storage/postgres.go (0.0%)</option>
				
				<option value="file13">github.com/Vidkin/metrics/internal/router/metric_router.go (91.2%)</option>
				
				<option value="file14">github.com/Vidkin/metrics/internal/router/storage_factory.go (11.7%)</option>
				
				<option value="file15">github.com/Vidkin/metrics/pkg/compress/gzip.go (80.0%)</option>
				
				<option value="file16">github.com/Vidkin/metrics/pkg/hash/sha256.go (0.0%)</option>
				
				<option value="file17">github.com/Vidkin/metrics/pkg/middleware/gzip.go (75.0%)</option>
				
				<option value="file18">github.com/Vidkin/metrics/pkg/middleware/hash.go (0.0%)</option>
				
				<option value="file19">github.com/Vidkin/metrics/pkg/middleware/logging.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "context"
        "errors"
        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/internal/repository/storage"
        "github.com/Vidkin/metrics/internal/router"
        "github.com/go-chi/chi/v5"
        "go.uber.org/zap"
        "net/http"
        _ "net/http/pprof"
        "os"
        "os/signal"
        "syscall"
        "time"
)

type ServerApp struct {
        config     *config.ServerConfig
        srv        *http.Server
        repository router.Repository
        dump       bool
}

func NewServerApp(cfg *config.ServerConfig) (*ServerApp, error) <span class="cov0" title="0">{
        if err := logger.Initialize(cfg.LogLevel); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">repo, err := router.NewRepository(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">chiRouter := chi.NewRouter()
        metricRouter := router.NewMetricRouter(chiRouter, repo, cfg)

        srv := &amp;http.Server{
                Addr:    cfg.ServerAddress.Address,
                Handler: metricRouter.Router,
        }
        return &amp;ServerApp{
                config:     cfg,
                srv:        srv,
                repository: repo,
        }, nil</span>
}

func (a *ServerApp) Serve() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                err := http.ListenAndServe("localhost:6060", nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error start pprof endpoint", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">if err := a.srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                logger.Log.Fatal("listen and serve fatal error", zap.Error(err))
        }</span>
}

func (a *ServerApp) DumpToFile() error <span class="cov0" title="0">{
        if dumper, ok := a.repository.(router.Dumper); ok </span><span class="cov0" title="0">{
                for i := 0; i &lt;= a.config.RetryCount; i++ </span><span class="cov0" title="0">{
                        err := dumper.FullDump()
                        if err != nil </span><span class="cov0" title="0">{
                                var pathErr *os.PathError
                                if errors.As(err, &amp;pathErr) &amp;&amp; i != a.config.RetryCount </span><span class="cov0" title="0">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                                <span class="cov0" title="0">logger.Log.Info("error saving metrics", zap.Error(err))</span>
                        }
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">return errors.New("provided Repository does not implement Dumper")</span>
}

func (a *ServerApp) Run() <span class="cov0" title="0">{
        logger.Log.Info("running server", zap.String("address", a.config.ServerAddress.Address))

        go a.Serve()
        if a.config.StoreInterval &gt; 0 </span><span class="cov0" title="0">{
                ticker := time.NewTicker(time.Duration(a.config.StoreInterval) * time.Second)
                go func() </span><span class="cov0" title="0">{
                        for range ticker.C </span><span class="cov0" title="0">{
                                if err := a.DumpToFile(); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Info("error interval dump", zap.Error(err))
                                }</span>
                        }
                }()
        }

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        defer a.Stop()</span>
}

func (a *ServerApp) Stop() <span class="cov0" title="0">{
        logger.Log.Info("stop server", zap.String("address", a.config.ServerAddress.Address))
        // Создаем контекст с таймаутом для корректного завершения сервера
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Останавливаем сервер, ожидая завершения текущих обработчиков
        if err := a.srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("shutdown error", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Log.Info("dump metrics before exit")
        if _, ok := a.repository.(*storage.FileStorage); ok </span><span class="cov0" title="0">{
                if err := a.DumpToFile(); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error dump metrics before exit", zap.Error(err))
                }</span>
        }
        <span class="cov0" title="0">err := router.Close(a.repository)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error close repository before exit", zap.Error(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "github.com/Vidkin/metrics/internal/agent"
        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/internal/router"
        "github.com/go-resty/resty/v2"
        "runtime"
)

func main() <span class="cov0" title="0">{
        agentConfig, err := config.NewAgentConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">if err := logger.Initialize(agentConfig.LogLevel); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">memoryStorage := router.NewFileStorage("")
        memStats := &amp;runtime.MemStats{}
        client := resty.New()
        client.SetDoNotParseResponse(true)
        mw := agent.New(memoryStorage, memStats, client, agentConfig)

        mw.Poll()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "github.com/Vidkin/metrics/app"
        "github.com/Vidkin/metrics/internal/config"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.NewServerConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">serverApp, err := app.NewServerApp(cfg)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">serverApp.Run()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package agent

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "errors"
        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/internal/metric"
        "github.com/Vidkin/metrics/internal/router"
        "github.com/Vidkin/metrics/pkg/hash"
        "github.com/go-resty/resty/v2"
        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/mem"
        "go.uber.org/zap"
        "io"
        "math/rand/v2"
        "net/url"
        "runtime"
        "strconv"
        "strings"
        "time"
)

const (
        GaugeMetricAlloc          = "Alloc"
        GaugeMetricBuckHashSys    = "BuckHashSys"
        GaugeMetricFrees          = "Frees"
        GaugeMetricGCCPUFraction  = "GCCPUFraction"
        GaugeMetricGCSys          = "GCSys"
        GaugeMetricHeapAlloc      = "HeapAlloc"
        GaugeMetricHeapIdle       = "HeapIdle"
        GaugeMetricHeapInuse      = "HeapInuse"
        GaugeMetricHeapObjects    = "HeapObjects"
        GaugeMetricHeapReleased   = "HeapReleased"
        GaugeMetricHeapSys        = "HeapSys"
        GaugeMetricLastGC         = "LastGC"
        GaugeMetricLookups        = "Lookups"
        GaugeMetricMCacheInuse    = "MCacheInuse"
        GaugeMetricMCacheSys      = "MCacheSys"
        GaugeMetricMSpanInuse     = "MSpanInuse"
        GaugeMetricMSpanSys       = "MSpanSys"
        GaugeMetricMallocs        = "Mallocs"
        GaugeMetricNextGC         = "NextGC"
        GaugeMetricNumForcedGC    = "NumForcedGC"
        GaugeMetricNumGC          = "NumGC"
        GaugeMetricOtherSys       = "OtherSys"
        GaugeMetricPauseTotalNs   = "PauseTotalNs"
        GaugeMetricStackInuse     = "StackInuse"
        GaugeMetricStackSys       = "StackSys"
        GaugeMetricSys            = "Sys"
        GaugeMetricTotalAlloc     = "TotalAlloc"
        GaugeMetricRandomValue    = "RandomValue"
        GaugeMetricTotalMemory    = "TotalMemory"
        GaugeMetricFreeMemory     = "FreeMemory"
        GaugeMetricCPUutilization = "CPUutilization"

        CounterMetricPollCount = "PollCount"

        MetricTypeCounter = "counter"
        MetricTypeGauge   = "gauge"

        RequestRetryCount = 3
)

type MetricWorker struct {
        repository router.Repository
        memStats   *runtime.MemStats
        client     *resty.Client
        config     *config.AgentConfig
}

func New(repository router.Repository, memStats *runtime.MemStats, client *resty.Client, config *config.AgentConfig) *MetricWorker <span class="cov8" title="1">{
        return &amp;MetricWorker{
                repository: repository,
                memStats:   memStats,
                client:     client,
                config:     config,
        }
}</span>

func (mw *MetricWorker) CollectMetrics(chIn chan *metric.Metric, count int64) <span class="cov8" title="1">{
        defer close(chIn)
        runtime.ReadMemStats(mw.memStats)

        vmStat, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error collect memory metrics", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">totalMemory := vmStat.Total / 1024 / 1024
        freeMemory := vmStat.Free / 1024 / 1024

        percentages, err := cpu.Percent(0, true)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error collect cpu utilization metrics", zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">gaugeMetrics := map[string]float64{
                GaugeMetricAlloc:         float64(mw.memStats.Alloc),
                GaugeMetricBuckHashSys:   float64(mw.memStats.BuckHashSys),
                GaugeMetricFrees:         float64(mw.memStats.Frees),
                GaugeMetricMCacheSys:     float64(mw.memStats.MCacheSys),
                GaugeMetricMSpanInuse:    float64(mw.memStats.MSpanInuse),
                GaugeMetricNumForcedGC:   float64(mw.memStats.NumForcedGC),
                GaugeMetricGCCPUFraction: mw.memStats.GCCPUFraction,
                GaugeMetricGCSys:         float64(mw.memStats.GCSys),
                GaugeMetricHeapAlloc:     float64(mw.memStats.HeapAlloc),
                GaugeMetricHeapIdle:      float64(mw.memStats.HeapIdle),
                GaugeMetricHeapInuse:     float64(mw.memStats.HeapInuse),
                GaugeMetricHeapObjects:   float64(mw.memStats.HeapObjects),
                GaugeMetricHeapReleased:  float64(mw.memStats.HeapReleased),
                GaugeMetricHeapSys:       float64(mw.memStats.HeapSys),
                GaugeMetricLastGC:        float64(mw.memStats.LastGC),
                GaugeMetricLookups:       float64(mw.memStats.Lookups),
                GaugeMetricMCacheInuse:   float64(mw.memStats.MCacheInuse),
                GaugeMetricMSpanSys:      float64(mw.memStats.MSpanSys),
                GaugeMetricMallocs:       float64(mw.memStats.Mallocs),
                GaugeMetricNextGC:        float64(mw.memStats.NextGC),
                GaugeMetricNumGC:         float64(mw.memStats.NumGC),
                GaugeMetricOtherSys:      float64(mw.memStats.OtherSys),
                GaugeMetricPauseTotalNs:  float64(mw.memStats.PauseTotalNs),
                GaugeMetricStackInuse:    float64(mw.memStats.StackInuse),
                GaugeMetricStackSys:      float64(mw.memStats.StackSys),
                GaugeMetricSys:           float64(mw.memStats.Sys),
                GaugeMetricTotalAlloc:    float64(mw.memStats.TotalAlloc),
                GaugeMetricTotalMemory:   float64(totalMemory),
                GaugeMetricFreeMemory:    float64(freeMemory),
                GaugeMetricRandomValue:   rand.Float64(),
        }
        for i, percentage := range percentages </span><span class="cov8" title="1">{
                gaugeMetrics[GaugeMetricCPUutilization+strconv.Itoa(i+1)] = percentage
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()
        for k, v := range gaugeMetrics </span><span class="cov8" title="1">{
                gMetric := &amp;metric.Metric{
                        ID:    k,
                        MType: MetricTypeGauge,
                        Value: &amp;v,
                }
                err = mw.repository.UpdateMetric(ctx, gMetric)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error update gauge metric", zap.Error(err))
                        return
                }</span>
                <span class="cov8" title="1">chIn &lt;- gMetric</span>
        }
        <span class="cov8" title="1">cMetric := &amp;metric.Metric{
                ID:    CounterMetricPollCount,
                MType: MetricTypeCounter,
                Delta: &amp;count,
        }
        err = mw.repository.UpdateMetric(ctx, cMetric)
        chIn &lt;- cMetric
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error update counter metric", zap.Error(err))
                return
        }</span>
}

func (mw *MetricWorker) SendMetric(url string, metric *metric.Metric) (int, string, error) <span class="cov8" title="1">{
        body, err := json.Marshal(metric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal body", zap.Error(err))
                return 0, "", err
        }</span>

        <span class="cov8" title="1">buf := bytes.NewBuffer(nil)
        zb := gzip.NewWriter(buf)
        _, err = zb.Write(body)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error gzip body", zap.Error(err))
                return 0, "", err
        }</span>

        <span class="cov8" title="1">err = zb.Close()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error close gzip buffer", zap.Error(err))
                return 0, "", err
        }</span>

        <span class="cov8" title="1">resp, err := mw.client.R().
                SetHeader("Content-Type", "application/json").
                SetHeader("Content-Encoding", "gzip").
                SetHeader("Accept-Encoding", "gzip").
                SetBody(buf).
                Post(url)

        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error post request", zap.Error(err))
                return 0, "", err
        }</span>
        <span class="cov8" title="1">defer func(body io.ReadCloser) </span><span class="cov8" title="1">{
                err := body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error close resp raw body", zap.Error(err))
                }</span>
        }(resp.RawBody())

        <span class="cov8" title="1">contentEncoding := resp.Header().Get("Content-Encoding")
        var or io.ReadCloser
        if strings.Contains(contentEncoding, "gzip") </span><span class="cov8" title="1">{
                cr, err := gzip.NewReader(resp.RawBody())
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error init gzip reader", zap.Error(err))
                        return 0, "", err
                }</span>
                <span class="cov8" title="1">or = cr</span>
        } else<span class="cov8" title="1"> {
                or = resp.RawBody()
        }</span>
        <span class="cov8" title="1">respBody, err := io.ReadAll(or)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error read response body", zap.Error(err))
                return 0, "", err
        }</span>

        <span class="cov8" title="1">return resp.StatusCode(), string(respBody), nil</span>
}

func (mw *MetricWorker) SendMetrics(chIn chan *metric.Metric, serverURL string) <span class="cov8" title="1">{
        for m := range chIn </span><span class="cov8" title="1">{
                body, _ := json.Marshal([]*metric.Metric{m})
                buf := bytes.NewBuffer([]byte{})
                zb := gzip.NewWriter(buf)
                _, _ = zb.Write(body)
                err := zb.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error close gzip writer", zap.Error(err))
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt;= RequestRetryCount; i++ </span><span class="cov8" title="1">{
                        req := mw.client.R()
                        if mw.config.Key != "" </span><span class="cov0" title="0">{
                                h := hash.GetHashSHA256(mw.config.Key, buf.Bytes())
                                hEnc := base64.StdEncoding.EncodeToString(h)
                                req.SetHeader("HashSHA256", hEnc)
                        }</span>
                        <span class="cov8" title="1">_, err := req.
                                SetHeader("Content-Type", "application/json").
                                SetHeader("Content-Encoding", "gzip").
                                SetHeader("Accept-Encoding", "gzip").
                                SetBody(buf).
                                Post(serverURL)
                        if err != nil </span><span class="cov0" title="0">{
                                var urlErr *url.Error
                                if errors.As(err, &amp;urlErr) &amp;&amp; i != RequestRetryCount </span><span class="cov0" title="0">{
                                        logger.Log.Info("error post request", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                                <span class="cov0" title="0">logger.Log.Info("error post request", zap.Error(err))
                                return</span>
                        }
                        <span class="cov8" title="1">break</span>
                }
        }
}

func (mw *MetricWorker) Poll() <span class="cov0" title="0">{
        startTime := time.Now()
        var serverURL = "http://" + mw.config.ServerAddress.Address + "/updates/"
        var count int64 = 0
        for </span><span class="cov0" title="0">{
                currentTime := time.Now()
                chIn := make(chan *metric.Metric, mw.config.RateLimit)
                go mw.CollectMetrics(chIn, count)

                if currentTime.Sub(startTime).Seconds() &gt;= float64(mw.config.ReportInterval) </span><span class="cov0" title="0">{
                        startTime = currentTime
                        for w := 1; w &lt;= mw.config.RateLimit; w++ </span><span class="cov0" title="0">{
                                go mw.SendMetrics(chIn, serverURL)
                        }</span>
                }
                <span class="cov0" title="0">time.Sleep(time.Duration(mw.config.PollInterval) * time.Second)
                count++</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "flag"
        "github.com/caarlos0/env/v6"
)

const (
        DefaultAgentPollInterval   = 2
        DefaultAgentReportInterval = 10
)

type AgentConfig struct {
        ServerAddress  *ServerAddress
        ReportInterval int    `env:"REPORT_INTERVAL"`
        PollInterval   int    `env:"POLL_INTERVAL"`
        Key            string `env:"KEY"`
        RateLimit      int    `env:"RATE_LIMIT"`
        LogLevel       string
}

func NewAgentConfig() (*AgentConfig, error) <span class="cov0" title="0">{
        var config AgentConfig
        config.ServerAddress = NewServerAddress()
        config.LogLevel = "info"
        err := config.parseFlags()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (config *AgentConfig) parseFlags() error <span class="cov0" title="0">{
        flag.Var(config.ServerAddress, "a", "Server address host:port")
        flag.IntVar(&amp;config.ReportInterval, "r", DefaultAgentReportInterval, "Agent report poll interval (sec)")
        flag.IntVar(&amp;config.PollInterval, "p", DefaultAgentPollInterval, "Agent poll interval (sec)")
        flag.IntVar(&amp;config.RateLimit, "l", 5, "Rate limit")
        flag.StringVar(&amp;config.Key, "k", "", "Hash key")
        flag.Parse()

        err := env.Parse(config.ServerAddress)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if config.ServerAddress.Address == "" </span><span class="cov0" title="0">{
                config.ServerAddress.Address = config.ServerAddress.String()
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "errors"
        "strconv"
        "strings"
)

const (
        DefaultServerAddress = "localhost"
        DefaultServerPort    = 8080
)

type ServerAddress struct {
        Host    string
        Port    int
        Address string `env:"ADDRESS"`
}

func NewServerAddress() *ServerAddress <span class="cov0" title="0">{
        return &amp;ServerAddress{
                Host: DefaultServerAddress,
                Port: DefaultServerPort,
        }
}</span>

func (s *ServerAddress) String() string <span class="cov0" title="0">{
        return s.Host + ":" + strconv.Itoa(s.Port)
}</span>

func (s *ServerAddress) Set(flagRunAddr string) error <span class="cov0" title="0">{
        splittedAddress := strings.Split(flagRunAddr, ":")

        if len(splittedAddress) != 2 </span><span class="cov0" title="0">{
                return errors.New("need address in a form host:port")
        }</span>

        <span class="cov0" title="0">port, err := strconv.Atoi(splittedAddress[1])

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.Host = splittedAddress[0]
        s.Port = port

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "flag"
        "github.com/caarlos0/env/v6"
)

type ServerConfig struct {
        ServerAddress   *ServerAddress
        StoreInterval   int    `env:"STORE_INTERVAL"`
        FileStoragePath string `env:"FILE_STORAGE_PATH"`
        Restore         bool   `env:"RESTORE"`
        DatabaseDSN     string `env:"DATABASE_DSN"`
        Key             string `env:"KEY"`
        RetryCount      int
        LogLevel        string
}

func NewServerConfig() (*ServerConfig, error) <span class="cov0" title="0">{
        var config ServerConfig
        config.ServerAddress = NewServerAddress()
        config.RetryCount = 3
        err := config.parseFlags()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (config *ServerConfig) parseFlags() error <span class="cov0" title="0">{
        flag.Var(config.ServerAddress, "a", "Net address host:port")
        flag.StringVar(&amp;config.LogLevel, "l", "info", "Log level")
        flag.IntVar(&amp;config.StoreInterval, "i", 300, "Config store interval")
        flag.StringVar(&amp;config.FileStoragePath, "f", "", "Metrics file storage path")
        flag.StringVar(&amp;config.DatabaseDSN, "d", "", "Database DSN")
        flag.StringVar(&amp;config.Key, "k", "", "Hash key")
        flag.BoolVar(&amp;config.Restore, "r", true, "Restore metrics on startup")
        flag.Parse()

        err := env.Parse(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if config.ServerAddress.Address == "" </span><span class="cov0" title="0">{
                config.ServerAddress.Address = config.ServerAddress.String()
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package logger

import (
        "go.uber.org/zap"
)

var Log *zap.Logger = zap.NewNop()

func Initialize(logLevel string) error <span class="cov0" title="0">{
        lvl, err := zap.ParseAtomicLevel(logLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cfg := zap.NewProductionConfig()
        cfg.Level = lvl

        logger, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer logger.Sync()

        Log = logger
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package metric

import (
        "strconv"
)

type Metric struct {
        ID    string   `json:"id"`              // имя метрики
        MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
        Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
        Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
}

func (m *Metric) ValueAsString() string <span class="cov8" title="1">{
        if m.MType == "gauge" </span><span class="cov8" title="1">{
                return strconv.FormatFloat(*m.Value, 'g', -1, 64)
        }</span>
        <span class="cov8" title="1">return strconv.FormatInt(*m.Delta, 10)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Vidkin/metrics/internal/router (interfaces: Repository)

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        metric "github.com/Vidkin/metrics/internal/metric"
        gomock "github.com/golang/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov8" title="1">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// DeleteMetric mocks base method.
func (m *MockRepository) DeleteMetric(arg0 context.Context, arg1, arg2 string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteMetric", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteMetric indicates an expected call of DeleteMetric.
func (mr *MockRepositoryMockRecorder) DeleteMetric(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMetric", reflect.TypeOf((*MockRepository)(nil).DeleteMetric), arg0, arg1, arg2)
}</span>

// GetCounters mocks base method.
func (m *MockRepository) GetCounters(arg0 context.Context) ([]*metric.Metric, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetCounters", arg0)
        ret0, _ := ret[0].([]*metric.Metric)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetCounters indicates an expected call of GetCounters.
func (mr *MockRepositoryMockRecorder) GetCounters(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCounters", reflect.TypeOf((*MockRepository)(nil).GetCounters), arg0)
}</span>

// GetGauges mocks base method.
func (m *MockRepository) GetGauges(arg0 context.Context) ([]*metric.Metric, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetGauges", arg0)
        ret0, _ := ret[0].([]*metric.Metric)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetGauges indicates an expected call of GetGauges.
func (mr *MockRepositoryMockRecorder) GetGauges(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGauges", reflect.TypeOf((*MockRepository)(nil).GetGauges), arg0)
}</span>

// GetMetric mocks base method.
func (m *MockRepository) GetMetric(arg0 context.Context, arg1, arg2 string) (*metric.Metric, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMetric", arg0, arg1, arg2)
        ret0, _ := ret[0].(*metric.Metric)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMetric indicates an expected call of GetMetric.
func (mr *MockRepositoryMockRecorder) GetMetric(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetric", reflect.TypeOf((*MockRepository)(nil).GetMetric), arg0, arg1, arg2)
}</span>

// GetMetrics mocks base method.
func (m *MockRepository) GetMetrics(arg0 context.Context) ([]*metric.Metric, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMetrics", arg0)
        ret0, _ := ret[0].([]*metric.Metric)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMetrics indicates an expected call of GetMetrics.
func (mr *MockRepositoryMockRecorder) GetMetrics(arg0 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetrics", reflect.TypeOf((*MockRepository)(nil).GetMetrics), arg0)
}</span>

// UpdateMetric mocks base method.
func (m *MockRepository) UpdateMetric(arg0 context.Context, arg1 *metric.Metric) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateMetric", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateMetric indicates an expected call of UpdateMetric.
func (mr *MockRepositoryMockRecorder) UpdateMetric(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMetric", reflect.TypeOf((*MockRepository)(nil).UpdateMetric), arg0, arg1)
}</span>

// UpdateMetrics mocks base method.
func (m *MockRepository) UpdateMetrics(arg0 context.Context, arg1 *[]metric.Metric) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateMetrics", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateMetrics indicates an expected call of UpdateMetrics.
func (mr *MockRepositoryMockRecorder) UpdateMetrics(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMetrics", reflect.TypeOf((*MockRepository)(nil).UpdateMetrics), arg0, arg1)
}</span>

// Dump mocks base method.
func (m *MockRepository) Dump(arg0 *metric.Metric) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Dump", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Dump indicates an expected call of Dump.
func (mr *MockRepositoryMockRecorder) Dump(arg0 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dump", reflect.TypeOf((*MockRepository)(nil).Dump), arg0)
}</span>

// FullDump mocks base method.
func (m *MockRepository) FullDump() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FullDump")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// FullDump indicates an expected call of FullDump.
func (mr *MockRepositoryMockRecorder) FullDump() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FullDump", reflect.TypeOf((*MockRepository)(nil).FullDump))
}</span>

// Ping mocks base method.
func (m *MockRepository) Ping(arg0 context.Context) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockRepositoryMockRecorder) Ping(arg0 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockRepository)(nil).Ping), arg0)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "errors"
        "github.com/Vidkin/metrics/internal/logger"
        me "github.com/Vidkin/metrics/internal/metric"
        "go.uber.org/zap"
        "io"
        "os"
)

type FileStorage struct {
        Gauge           map[string]float64
        Counter         map[string]int64
        GaugeMetrics    []*me.Metric
        CounterMetrics  []*me.Metric
        AllMetrics      []*me.Metric
        FileStoragePath string
}

func (f *FileStorage) UpdateMetric(_ context.Context, metric *me.Metric) error <span class="cov8" title="1">{
        switch metric.MType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                f.Gauge[metric.ID] = *metric.Value</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                f.Counter[metric.ID] += *metric.Delta</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (f *FileStorage) UpdateMetrics(_ context.Context, metrics *[]me.Metric) error <span class="cov0" title="0">{
        for _, metric := range *metrics </span><span class="cov0" title="0">{
                switch metric.MType </span>{
                case MetricTypeGauge:<span class="cov0" title="0">
                        f.Gauge[metric.ID] = *metric.Value</span>
                case MetricTypeCounter:<span class="cov0" title="0">
                        f.Counter[metric.ID] += *metric.Delta</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (f *FileStorage) DeleteMetric(_ context.Context, mType string, name string) error <span class="cov0" title="0">{
        switch mType </span>{
        case MetricTypeGauge:<span class="cov0" title="0">
                delete(f.Gauge, name)</span>
        case MetricTypeCounter:<span class="cov0" title="0">
                delete(f.Counter, name)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (f *FileStorage) GetMetric(_ context.Context, mType string, name string) (*me.Metric, error) <span class="cov0" title="0">{
        var metric me.Metric
        switch mType </span>{
        case MetricTypeGauge:<span class="cov0" title="0">
                v, ok := f.Gauge[name]
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("metric not found")
                }</span>
                <span class="cov0" title="0">metric.ID = name
                metric.MType = MetricTypeGauge
                metric.Value = &amp;v</span>
        case MetricTypeCounter:<span class="cov0" title="0">
                v, ok := f.Counter[name]
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("metric not found")
                }</span>
                <span class="cov0" title="0">metric.ID = name
                metric.MType = MetricTypeCounter
                metric.Delta = &amp;v</span>
        }
        <span class="cov0" title="0">return &amp;metric, nil</span>
}

func (f *FileStorage) GetMetrics(ctx context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        f.AllMetrics = f.AllMetrics[:0]
        if _, err := f.GetGauges(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if _, err := f.GetCounters(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">f.AllMetrics = append(f.AllMetrics, f.GaugeMetrics...)
        f.AllMetrics = append(f.AllMetrics, f.CounterMetrics...)
        return f.AllMetrics, nil</span>
}

func (f *FileStorage) GetGauges(_ context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        f.GaugeMetrics = f.GaugeMetrics[:0]
        for k, v := range f.Gauge </span><span class="cov8" title="1">{
                f.GaugeMetrics = append(f.GaugeMetrics, &amp;me.Metric{
                        ID:    k,
                        Value: &amp;v,
                        MType: MetricTypeGauge,
                })
        }</span>
        <span class="cov8" title="1">return f.GaugeMetrics, nil</span>
}

func (f *FileStorage) GetCounters(_ context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        f.CounterMetrics = f.CounterMetrics[:0]
        for k, v := range f.Counter </span><span class="cov8" title="1">{
                f.CounterMetrics = append(f.CounterMetrics, &amp;me.Metric{
                        ID:    k,
                        Delta: &amp;v,
                        MType: MetricTypeCounter,
                })
        }</span>
        <span class="cov8" title="1">return f.CounterMetrics, nil</span>
}

func (f *FileStorage) Dump(metric *me.Metric) error <span class="cov0" title="0">{
        file, err := os.OpenFile(f.FileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                logger.Log.Info("error open file", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var metrics []me.Metric
        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error read file", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">if len(data) != 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(data, &amp;metrics); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">found := false
        for index, met := range metrics </span><span class="cov0" title="0">{
                if met.ID == metric.ID &amp;&amp; met.MType == metric.MType </span><span class="cov0" title="0">{
                        if met.MType == MetricTypeCounter </span><span class="cov0" title="0">{
                                metrics[index].Delta = metric.Delta
                        }</span>
                        <span class="cov0" title="0">if met.MType == MetricTypeGauge </span><span class="cov0" title="0">{
                                metrics[index].Value = metric.Value
                        }</span>
                        <span class="cov0" title="0">found = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                metrics = append(metrics, *metric)
        }</span>

        <span class="cov0" title="0">b, err := json.Marshal(metrics)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal metrics", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">err = os.WriteFile(f.FileStoragePath, b, 0666)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error write file", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (f *FileStorage) FullDump() error <span class="cov0" title="0">{
        file, err := os.OpenFile(f.FileStoragePath, os.O_WRONLY|os.O_APPEND|os.O_CREATE|os.O_TRUNC, 0666)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error open file", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        gauge, err := f.GetGauges(context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get gauges", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">counter, err := f.GetCounters(context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get counters", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">metrics := append(gauge, counter...)

        b, err := json.Marshal(metrics)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal metrics", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">_, err = file.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error write file", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (f *FileStorage) Load(ctx context.Context) error <span class="cov0" title="0">{
        file, err := os.OpenFile(f.FileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">logger.Log.Info("error open file", zap.Error(err))
                return err</span>
        }
        <span class="cov0" title="0">defer file.Close()

        var metrics []me.Metric
        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error read file", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;metrics); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, metric := range metrics </span><span class="cov0" title="0">{
                if err := f.UpdateMetric(ctx, &amp;metric); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package storage

import (
        "context"
        "errors"
        me "github.com/Vidkin/metrics/internal/metric"
        "sync"
)

const (
        MetricTypeCounter = "counter"
        MetricTypeGauge   = "gauge"
)

type MemoryStorage struct {
        mu             sync.RWMutex
        Gauge          map[string]float64
        Counter        map[string]int64
        GaugeMetrics   []*me.Metric
        CounterMetrics []*me.Metric
        AllMetrics     []*me.Metric
}

func (m *MemoryStorage) UpdateMetric(_ context.Context, metric *me.Metric) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        switch metric.MType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                m.Gauge[metric.ID] = *metric.Value</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                m.Counter[metric.ID] += *metric.Delta</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MemoryStorage) UpdateMetrics(_ context.Context, metrics *[]me.Metric) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for _, metric := range *metrics </span><span class="cov8" title="1">{
                switch metric.MType </span>{
                case MetricTypeGauge:<span class="cov8" title="1">
                        m.Gauge[metric.ID] = *metric.Value</span>
                case MetricTypeCounter:<span class="cov8" title="1">
                        m.Counter[metric.ID] += *metric.Delta</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MemoryStorage) DeleteMetric(_ context.Context, mType string, name string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        switch mType </span>{
        case MetricTypeGauge:<span class="cov0" title="0">
                delete(m.Gauge, name)</span>
        case MetricTypeCounter:<span class="cov0" title="0">
                delete(m.Counter, name)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *MemoryStorage) GetMetric(_ context.Context, mType string, name string) (*me.Metric, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var metric me.Metric
        switch mType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                v, ok := m.Gauge[name]
                if !ok </span><span class="cov8" title="1">{
                        return nil, errors.New("metric not found")
                }</span>
                <span class="cov8" title="1">metric.ID = name
                metric.MType = MetricTypeGauge
                metric.Value = &amp;v</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                v, ok := m.Counter[name]
                if !ok </span><span class="cov8" title="1">{
                        return nil, errors.New("metric not found")
                }</span>
                <span class="cov8" title="1">metric.ID = name
                metric.MType = MetricTypeCounter
                metric.Delta = &amp;v</span>
        }
        <span class="cov8" title="1">return &amp;metric, nil</span>
}

func (m *MemoryStorage) GetMetrics(ctx context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        m.AllMetrics = m.AllMetrics[:0]
        if _, err := m.GetGauges(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if _, err := m.GetCounters(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m.AllMetrics = append(m.AllMetrics, m.GaugeMetrics...)
        m.AllMetrics = append(m.AllMetrics, m.CounterMetrics...)
        return m.AllMetrics, nil</span>
}

func (m *MemoryStorage) GetGauges(_ context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        m.GaugeMetrics = m.GaugeMetrics[:0]
        for k, v := range m.Gauge </span><span class="cov8" title="1">{
                m.GaugeMetrics = append(m.GaugeMetrics, &amp;me.Metric{
                        ID:    k,
                        Value: &amp;v,
                        MType: MetricTypeGauge,
                })
        }</span>
        <span class="cov8" title="1">return m.GaugeMetrics, nil</span>
}

func (m *MemoryStorage) GetCounters(_ context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        m.CounterMetrics = m.CounterMetrics[:0]
        for k, v := range m.Counter </span><span class="cov8" title="1">{
                m.CounterMetrics = append(m.CounterMetrics, &amp;me.Metric{
                        ID:    k,
                        Delta: &amp;v,
                        MType: MetricTypeCounter,
                })
        }</span>
        <span class="cov8" title="1">return m.CounterMetrics, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package storage

import (
        "context"
        "database/sql"
        "embed"
        "errors"
        "github.com/Vidkin/metrics/internal/logger"
        me "github.com/Vidkin/metrics/internal/metric"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/jackc/pgx/v5/stdlib"
        "go.uber.org/zap"
)

//go:embed migrations/*.sql
var Migrations embed.FS

type PostgresStorage struct {
        GaugeMetrics   []*me.Metric
        CounterMetrics []*me.Metric
        AllMetrics     []*me.Metric
        Conn           *sql.DB
}

func (p *PostgresStorage) UpdateMetric(ctx context.Context, metric *me.Metric) error <span class="cov0" title="0">{
        switch metric.MType </span>{
        case MetricTypeGauge:<span class="cov0" title="0">
                _, err := p.GetMetric(ctx, metric.MType, metric.ID)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        _, err := p.Conn.ExecContext(ctx, "INSERT INTO gauge (metric_name, metric_value) VALUES ($1, $2)", metric.ID, *metric.Value)
                        return err
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error get gauge metric", zap.Error(err))
                        return err
                }</span>
                <span class="cov0" title="0">_, err = p.Conn.ExecContext(ctx, "UPDATE gauge SET metric_value=$1 WHERE metric_name=$2", *metric.Value, metric.ID)
                return err</span>
        case MetricTypeCounter:<span class="cov0" title="0">
                _, err := p.GetMetric(ctx, metric.MType, metric.ID)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        _, err := p.Conn.ExecContext(ctx, "INSERT INTO counter (metric_name, metric_value) VALUES ($1, $2)", metric.ID, *metric.Delta)
                        return err
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error get counter metric", zap.Error(err))
                        return err
                }</span>
                <span class="cov0" title="0">_, err = p.Conn.ExecContext(ctx, "UPDATE counter SET metric_value=metric_value+$1 WHERE metric_name=$2", *metric.Delta, metric.ID)
                return err</span>
        default:<span class="cov0" title="0">
                return errors.New("unknown metric type")</span>
        }
}

func (p *PostgresStorage) UpdateMetrics(ctx context.Context, metrics *[]me.Metric) error <span class="cov0" title="0">{
        tx, err := p.Conn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error begin tx", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()
        for _, metric := range *metrics </span><span class="cov0" title="0">{
                switch metric.MType </span>{
                case MetricTypeGauge:<span class="cov0" title="0">
                        row := tx.QueryRowContext(ctx, "SELECT metric_id from gauge WHERE metric_name=$1", metric.ID)
                        var metricID int64
                        err = row.Scan(&amp;metricID)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                                        _, err := tx.ExecContext(ctx, "INSERT INTO gauge (metric_name, metric_value) VALUES ($1, $2)", metric.ID, *metric.Value)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Info("error insert gauge metric", zap.Error(err))
                                                return err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logger.Log.Info("error scan gauge metric", zap.Error(err))
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, "UPDATE gauge SET metric_value=$1 WHERE metric_id=$2", *metric.Value, metricID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Info("error update gauge metric", zap.Error(err))
                                return err
                        }</span>
                case MetricTypeCounter:<span class="cov0" title="0">
                        row := tx.QueryRowContext(ctx, "SELECT metric_id from counter WHERE metric_name=$1", metric.ID)
                        var metricID int64
                        err = row.Scan(&amp;metricID)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                                        _, err := tx.ExecContext(ctx, "INSERT INTO counter (metric_name, metric_value) VALUES ($1, $2)", metric.ID, *metric.Delta)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Info("error insert counter metric", zap.Error(err))
                                                return err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logger.Log.Info("error scan counter metric", zap.Error(err))
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, "UPDATE counter SET metric_value=metric_value+$1 WHERE metric_id=$2", *metric.Delta, metricID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Info("error update counter metric", zap.Error(err))
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        logger.Log.Info("unknown metric type")
                        return errors.New("unknown metric type")</span>
                }
        }
        <span class="cov0" title="0">return tx.Commit()</span>
}

func (p *PostgresStorage) DeleteMetric(ctx context.Context, mType string, name string) error <span class="cov0" title="0">{
        switch mType </span>{
        case MetricTypeGauge:<span class="cov0" title="0">
                stmt, err := p.Conn.PrepareContext(ctx, "DELETE from gauge WHERE metric_name=$1")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error prepare stmt", zap.Error(err))
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()
                _, err = stmt.ExecContext(ctx, name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error delete gauge metric", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return err</span>
        case MetricTypeCounter:<span class="cov0" title="0">
                stmt, err := p.Conn.PrepareContext(ctx, "DELETE from counter WHERE metric_name=$1")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error prepare stmt", zap.Error(err))
                        return err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()
                _, err = stmt.ExecContext(ctx, name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error delete counter metric", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return err</span>
        default:<span class="cov0" title="0">
                logger.Log.Info("unknown metric type")
                return errors.New("unknown metric type")</span>
        }
}

func (p *PostgresStorage) GetMetric(ctx context.Context, mType string, name string) (*me.Metric, error) <span class="cov0" title="0">{
        switch mType </span>{
        case MetricTypeGauge:<span class="cov0" title="0">
                stmt, err := p.Conn.PrepareContext(ctx, "SELECT metric_name, metric_value from gauge WHERE metric_name=$1")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error prepare stmt", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()
                row := stmt.QueryRowContext(ctx, name)
                var m me.Metric
                err = row.Scan(&amp;m.ID, &amp;m.Value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error scan gauge metric", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">m.MType = MetricTypeGauge
                return &amp;m, nil</span>
        case MetricTypeCounter:<span class="cov0" title="0">
                stmt, err := p.Conn.PrepareContext(ctx, "SELECT metric_name, metric_value from counter WHERE metric_name=$1")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error prepare stmt", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer stmt.Close()
                row := stmt.QueryRowContext(ctx, name)
                var m me.Metric
                err = row.Scan(&amp;m.ID, &amp;m.Delta)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error scan counter metric", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">m.MType = MetricTypeCounter
                return &amp;m, nil</span>
        default:<span class="cov0" title="0">
                logger.Log.Info("unknown metric type")
                return nil, errors.New("unknown metric type")</span>
        }
}

func (p *PostgresStorage) GetMetrics(ctx context.Context) ([]*me.Metric, error) <span class="cov0" title="0">{
        p.AllMetrics = p.AllMetrics[:0]
        if _, err := p.GetGauges(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get gauges", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := p.GetCounters(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get counters", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">p.AllMetrics = append(p.AllMetrics, p.GaugeMetrics...)
        p.AllMetrics = append(p.AllMetrics, p.CounterMetrics...)
        return p.AllMetrics, nil</span>
}

func (p *PostgresStorage) GetGauges(ctx context.Context) ([]*me.Metric, error) <span class="cov0" title="0">{
        p.GaugeMetrics = p.GaugeMetrics[:0]
        stmt, err := p.Conn.PrepareContext(ctx, "SELECT metric_name, metric_value from gauge")
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error prepare stmt", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">defer stmt.Close()
        rows, err := stmt.QueryContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get gauges", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var m me.Metric
                if err := rows.Scan(&amp;m.ID, &amp;m.Value); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error scan gauge metric", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">m.MType = MetricTypeGauge
                p.GaugeMetrics = append(p.GaugeMetrics, &amp;m)</span>
        }
        <span class="cov0" title="0">if rows.Err() != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error rows", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return p.GaugeMetrics, nil</span>
}

func (p *PostgresStorage) GetCounters(ctx context.Context) ([]*me.Metric, error) <span class="cov0" title="0">{
        p.CounterMetrics = p.CounterMetrics[:0]
        stmt, err := p.Conn.PrepareContext(ctx, "SELECT metric_name, metric_value from counter")
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error prepare stmt", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">defer stmt.Close()
        rows, err := stmt.QueryContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get counters", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var m me.Metric
                if err := rows.Scan(&amp;m.ID, &amp;m.Delta); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error scan counter metric", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov0" title="0">m.MType = MetricTypeCounter
                p.CounterMetrics = append(p.CounterMetrics, &amp;m)</span>
        }
        <span class="cov0" title="0">if rows.Err() != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error rows", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return p.CounterMetrics, nil</span>
}

func (p *PostgresStorage) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return p.Conn.PingContext(ctx)
}</span>

func (p *PostgresStorage) Close() error <span class="cov0" title="0">{
        return p.Conn.Close()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package router

import (
        "context"
        "database/sql/driver"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/internal/metric"
        "github.com/Vidkin/metrics/pkg/middleware"
        "github.com/go-chi/chi/v5"
        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"
        "go.uber.org/zap"
        "io"
        "net/http"
        "os"
        "strconv"
        "time"
)

const (
        ParamMetricType  = "metricType"
        ParamMetricName  = "metricName"
        ParamMetricValue = "metricValue"

        MetricTypeCounter = "counter"
        MetricTypeGauge   = "gauge"
)

type MetricRouter struct {
        Repository    Repository
        Router        chi.Router
        RetryCount    int
        LastStoreTime time.Time
        StoreInterval int
}

type Repository interface {
        UpdateMetric(ctx context.Context, metric *metric.Metric) error
        UpdateMetrics(ctx context.Context, metrics *[]metric.Metric) error
        DeleteMetric(ctx context.Context, mType string, name string) error

        GetMetric(ctx context.Context, mType string, name string) (*metric.Metric, error)
        GetMetrics(ctx context.Context) ([]*metric.Metric, error)
        GetGauges(ctx context.Context) ([]*metric.Metric, error)
        GetCounters(ctx context.Context) ([]*metric.Metric, error)
}

type Dumper interface {
        Dump(metric *metric.Metric) error
        FullDump() error
}

func Ping(r Repository, ctx context.Context) error <span class="cov8" title="1">{
        if pinger, ok := r.(driver.Pinger); ok </span><span class="cov8" title="1">{
                return pinger.Ping(ctx)
        }</span>
        <span class="cov0" title="0">return errors.New("provided Repository does not implement Pinger")</span>
}

func DumpMetric(r Repository, m *metric.Metric) error <span class="cov8" title="1">{
        if dumper, ok := r.(Dumper); ok </span><span class="cov8" title="1">{
                return dumper.Dump(m)
        }</span>
        <span class="cov0" title="0">return errors.New("provided Repository does not implement Dumper")</span>
}

func Close(r Repository) error <span class="cov0" title="0">{
        if closer, ok := r.(io.Closer); ok </span><span class="cov0" title="0">{
                return closer.Close()
        }</span>
        <span class="cov0" title="0">return errors.New("provided Repository does not implement Closer")</span>
}

func NewMetricRouter(router *chi.Mux, repository Repository, serverConfig *config.ServerConfig) *MetricRouter <span class="cov8" title="1">{
        var mr MetricRouter
        router.Use(middleware.Logging)
        if serverConfig.Key != "" </span><span class="cov0" title="0">{
                router.Use(middleware.Hash(serverConfig.Key))
        }</span>
        <span class="cov8" title="1">router.Use(middleware.Gzip)

        router.Route("/", func(r chi.Router) </span><span class="cov8" title="1">{
                r.Get("/", mr.RootHandler)
                r.Route("/ping", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Get("/", mr.PingDBHandler)
                }</span>)
                <span class="cov8" title="1">r.Route("/value", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/", mr.GetMetricValueHandlerJSON)
                        r.Get("/{metricType}/{metricName}", mr.GetMetricValueHandler)
                }</span>)
                <span class="cov8" title="1">r.Route("/update", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/", mr.UpdateMetricHandlerJSON)
                        r.Post("/{metricType}/{metricName}/{metricValue}", mr.UpdateMetricHandler)
                }</span>)
                <span class="cov8" title="1">r.Route("/updates", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/", mr.UpdateMetricsHandlerJSON)
                }</span>)
        })
        <span class="cov8" title="1">mr.Router = router
        mr.Repository = repository
        mr.StoreInterval = serverConfig.StoreInterval
        mr.RetryCount = serverConfig.RetryCount
        mr.LastStoreTime = time.Now()
        return &amp;mr</span>
}

func (mr *MetricRouter) RootHandler(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        res.Header().Set("Content-Type", "text/html")

        var (
                metrics []*metric.Metric
                err     error
        )

        for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                metrics, err = mr.Repository.GetMetrics(req.Context())
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("error get metrics", zap.Error(err))
                        http.Error(res, "error get metrics", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">for _, me := range metrics </span><span class="cov8" title="1">{
                if me.MType == MetricTypeGauge </span><span class="cov8" title="1">{
                        _, _ = io.WriteString(res, fmt.Sprintf("%s = %v\n", me.ID, *me.Value))
                }</span>
                <span class="cov8" title="1">if me.MType == MetricTypeCounter </span><span class="cov8" title="1">{
                        _, _ = io.WriteString(res, fmt.Sprintf("%s = %d\n", me.ID, *me.Delta))
                }</span>
        }
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

func (mr *MetricRouter) PingDBHandler(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        res.Header().Set("Content-Type", "text/plain")
        if err := Ping(mr.Repository, req.Context()); err != nil </span><span class="cov8" title="1">{
                logger.Log.Info("couldn't connect to database")
                res.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

func (mr *MetricRouter) GetMetricValueHandler(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        metricType := chi.URLParam(req, ParamMetricType)
        metricName := chi.URLParam(req, ParamMetricName)

        if metricType != MetricTypeGauge &amp;&amp; metricType != MetricTypeCounter </span><span class="cov8" title="1">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var (
                me  *metric.Metric
                err error
        )

        for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                me, err = mr.Repository.GetMetric(req.Context(), metricType, metricName)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("metric not found", zap.Error(err))
                        http.Error(res, "metric not found", http.StatusNotFound)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">_, err = res.Write([]byte(me.ValueAsString()))
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("can't write metric value", zap.Error(err))
                http.Error(res, "Can't write metric value", http.StatusInternalServerError)
        }</span>

        <span class="cov8" title="1">res.Header().Set("Content-Type", "text/plain; charset=utf-8")
        res.WriteHeader(http.StatusOK)</span>
}

func (mr *MetricRouter) DumpMetric(metric *metric.Metric) error <span class="cov8" title="1">{
        if mr.StoreInterval == 0 </span><span class="cov8" title="1">{
                for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                        err := DumpMetric(mr.Repository, metric)
                        if err != nil </span><span class="cov8" title="1">{
                                var pathErr *os.PathError
                                if errors.As(err, &amp;pathErr) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                                <span class="cov8" title="1">logger.Log.Info("error saving metric", zap.Error(err))
                                return errors.New("error saving metric")</span>
                        }
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (mr *MetricRouter) UpdateMetricHandler(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        metricType := chi.URLParam(req, ParamMetricType)
        metricName := chi.URLParam(req, ParamMetricName)
        metricValue := chi.URLParam(req, ParamMetricValue)

        if metricName == "" </span><span class="cov0" title="0">{
                http.Error(res, "Empty metric name!", http.StatusNotFound)
        }</span>

        <span class="cov8" title="1">if metricType != MetricTypeGauge &amp;&amp; metricType != MetricTypeCounter </span><span class="cov8" title="1">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">me := metric.Metric{
                ID:    metricName,
                MType: metricType,
        }

        var (
                floatValue float64
                intValue   int64
                err        error
        )

        if metricType == MetricTypeGauge </span><span class="cov8" title="1">{
                floatValue, err = strconv.ParseFloat(metricValue, 64)
                me.Value = &amp;floatValue
        }</span>

        <span class="cov8" title="1">if metricType == MetricTypeCounter </span><span class="cov8" title="1">{
                intValue, err = strconv.ParseInt(metricValue, 10, 64)
                me.Delta = &amp;intValue
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                logger.Log.Info("can't convert metric value", zap.Error(err))
                http.Error(res, "Bad metric value!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                err := mr.Repository.UpdateMetric(req.Context(), &amp;me)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("bad metric value", zap.Error(err))
                        http.Error(res, "bad metric value", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if err := mr.DumpMetric(&amp;me); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "error saving metric", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.Header().Set("Content-Type", "text/plain; charset=utf-8")
        res.WriteHeader(http.StatusOK)</span>
}

func (mr *MetricRouter) UpdateMetricHandlerJSON(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                http.Error(res, "only application/json content-type allowed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var me metric.Metric
        if err := json.NewDecoder(req.Body).Decode(&amp;me); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "can't decode request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">switch me.MType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                if me.Value == nil </span><span class="cov8" title="1">{
                        http.Error(res, "empty metric value", http.StatusBadRequest)
                        return
                }</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                if me.Delta == nil </span><span class="cov8" title="1">{
                        http.Error(res, "empty metric delta", http.StatusBadRequest)
                        return
                }</span>
        default:<span class="cov8" title="1">
                http.Error(res, "bad metric type", http.StatusBadRequest)
                return</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                err := mr.Repository.UpdateMetric(req.Context(), &amp;me)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("error update metric", zap.Error(err))
                        http.Error(res, "error update metric", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if err := mr.DumpMetric(&amp;me); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "error saving metric", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">var (
                actualMetric *metric.Metric
                err          error
        )
        for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                actualMetric, err = mr.Repository.GetMetric(req.Context(), me.MType, me.ID)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("error get actual metric value", zap.Error(err))
                        http.Error(res, "error get actual metric value", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">res.Header().Set("Content-Type", "application/json")
        data, err := json.Marshal(actualMetric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal json response", zap.Error(err))
                http.Error(res, "error marshal json response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">_, err = res.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error write response data", zap.Error(err))
                http.Error(res, "error write response data", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

func (mr *MetricRouter) GetMetricValueHandlerJSON(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                http.Error(res, "only application/json content-type allowed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var me metric.Metric
        if err := json.NewDecoder(req.Body).Decode(&amp;me); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "can't decode request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if me.MType != MetricTypeGauge &amp;&amp; me.MType != MetricTypeCounter </span><span class="cov8" title="1">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var (
                respMetric *metric.Metric
                err        error
        )
        for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                respMetric, err = mr.Repository.GetMetric(req.Context(), me.MType, me.ID)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("metric not found", zap.Error(err))
                        http.Error(res, "metric not found", http.StatusNotFound)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">res.Header().Set("Content-Type", "application/json")

        data, err := json.Marshal(respMetric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal json response", zap.Error(err))
                http.Error(res, "error marshal json response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">_, err = res.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error write response data", zap.Error(err))
                http.Error(res, "error write response data", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

func (mr *MetricRouter) UpdateMetricsHandlerJSON(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                http.Error(res, "only application/json content-type allowed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var metrics []metric.Metric
        if err := json.NewDecoder(req.Body).Decode(&amp;metrics); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "can't decode request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">defer func(body io.ReadCloser) </span><span class="cov8" title="1">{
                err := body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("can't close request body", zap.Error(err))
                }</span>
        }(req.Body)

        <span class="cov8" title="1">for _, m := range metrics </span><span class="cov8" title="1">{
                if (m.Value == nil &amp;&amp; m.Delta == nil) || (m.MType != MetricTypeCounter &amp;&amp; m.MType != MetricTypeGauge) </span><span class="cov8" title="1">{
                        http.Error(res, "bad metric", http.StatusBadRequest)
                        return
                }</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                err := mr.Repository.UpdateMetrics(req.Context(), &amp;metrics)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("error update metrics", zap.Error(err))
                        http.Error(res, "error update metrics", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">for _, me := range metrics </span><span class="cov8" title="1">{
                if err := mr.DumpMetric(&amp;me); err != nil </span><span class="cov8" title="1">{
                        http.Error(res, "error saving metric", http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov8" title="1">for i, m := range metrics </span><span class="cov8" title="1">{
                var (
                        updated *metric.Metric
                        err     error
                )
                for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                        updated, err = mr.Repository.GetMetric(req.Context(), m.MType, m.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                var pgErr *pgconn.PgError
                                if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                        if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                                logger.Log.Info("repository connection error", zap.Error(err))
                                                time.Sleep(time.Duration(1+i*2) * time.Second)
                                                continue</span>
                                        }
                                }
                                <span class="cov8" title="1">logger.Log.Info("error get updated metric", zap.Error(err))
                                http.Error(res, "error get updated metric", http.StatusInternalServerError)
                                return</span>
                        }
                        <span class="cov8" title="1">break</span>
                }
                <span class="cov8" title="1">metrics[i] = *updated</span>
        }
        <span class="cov8" title="1">res.Header().Set("Content-Type", "application/json")
        res.WriteHeader(http.StatusOK)
        enc := json.NewEncoder(res)
        if err := enc.Encode(metrics); err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error encoding response", zap.Error(err))
                http.Error(res, "error encoding response", http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package router

import (
        "context"
        "database/sql"
        "errors"
        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        me "github.com/Vidkin/metrics/internal/metric"
        "github.com/Vidkin/metrics/internal/repository/storage"
        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        "github.com/golang-migrate/migrate/v4/source/iofs"
        "go.uber.org/zap"
        "os"
        "time"
)

func NewMemoryStorage() *storage.MemoryStorage <span class="cov8" title="1">{
        var m storage.MemoryStorage
        m.Gauge = make(map[string]float64)
        m.Counter = make(map[string]int64)
        m.GaugeMetrics = make([]*me.Metric, 0)
        m.CounterMetrics = make([]*me.Metric, 0)
        m.AllMetrics = make([]*me.Metric, 0)
        return &amp;m
}</span>

func NewFileStorage(fileStoragePath string) *storage.FileStorage <span class="cov0" title="0">{
        var f storage.FileStorage
        f.Gauge = make(map[string]float64)
        f.Counter = make(map[string]int64)
        f.GaugeMetrics = make([]*me.Metric, 0)
        f.CounterMetrics = make([]*me.Metric, 0)
        f.AllMetrics = make([]*me.Metric, 0)
        f.FileStoragePath = fileStoragePath
        return &amp;f
}</span>

func NewPostgresStorage(dbDSN string) (*storage.PostgresStorage, error) <span class="cov0" title="0">{
        var p storage.PostgresStorage
        p.GaugeMetrics = make([]*me.Metric, 0)
        p.CounterMetrics = make([]*me.Metric, 0)
        p.AllMetrics = make([]*me.Metric, 0)

        db, err := sql.Open("pgx", dbDSN)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("error open sql connection", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("can't create postgres driver for migrations", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">d, err := iofs.New(storage.Migrations, "migrations")
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("can't get migrations from FS", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">m, err := migrate.NewWithInstance("iofs", d, "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("can't create new migrate instance", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                logger.Log.Fatal("can't exec migrations", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">p.Conn = db
        return &amp;p, nil</span>
}

func NewRepository(cfg *config.ServerConfig) (Repository, error) <span class="cov0" title="0">{
        if cfg.DatabaseDSN != "" </span><span class="cov0" title="0">{
                return NewPostgresStorage(cfg.DatabaseDSN)
        }</span>

        <span class="cov0" title="0">if cfg.FileStoragePath != "" </span><span class="cov0" title="0">{
                fileStorage := NewFileStorage(cfg.FileStoragePath)
                if cfg.Restore </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
                        defer cancel()

                        for i := 0; i &lt;= cfg.RetryCount; i++ </span><span class="cov0" title="0">{
                                err := fileStorage.Load(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        var pathErr *os.PathError
                                        if errors.As(err, &amp;pathErr) &amp;&amp; i != cfg.RetryCount </span><span class="cov0" title="0">{
                                                logger.Log.Info("repository connection error", zap.Error(err))
                                                time.Sleep(time.Duration(1+i*2) * time.Second)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">logger.Log.Info("error load saved metrics", zap.Error(err))</span>
                                }
                                <span class="cov0" title="0">break</span>
                        }
                }
                <span class="cov0" title="0">return fileStorage, nil</span>
        }

        <span class="cov0" title="0">memStorage := NewMemoryStorage()
        return memStorage, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package compress

import (
        "compress/gzip"
        "github.com/Vidkin/metrics/internal/logger"
        "go.uber.org/zap"
        "io"
        "net/http"
)

type Writer struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

func NewCompressWriter(w http.ResponseWriter) *Writer <span class="cov8" title="1">{
        return &amp;Writer{
                w:  w,
                zw: gzip.NewWriter(w),
        }
}</span>

func (c *Writer) Header() http.Header <span class="cov8" title="1">{
        return c.w.Header()
}</span>

func (c *Writer) Write(p []byte) (int, error) <span class="cov8" title="1">{
        c.w.Header().Set("Content-Encoding", "gzip")
        return c.zw.Write(p)
}</span>

func (c *Writer) WriteHeader(statusCode int) <span class="cov8" title="1">{
        c.w.WriteHeader(statusCode)
}</span>

func (c *Writer) Close() error <span class="cov8" title="1">{
        return c.zw.Close()
}</span>

type Reader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

func NewCompressReader(r io.ReadCloser) (*Reader, error) <span class="cov8" title="1">{
        zr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error init compress reader", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Reader{
                r:  r,
                zr: zr,
        }, nil</span>
}

func (c Reader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return c.zr.Read(p)
}</span>
func (c *Reader) Close() error <span class="cov8" title="1">{
        if err := c.r.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.zr.Close()</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package hash

import "crypto/sha256"

func GetHashSHA256(key string, data []byte) []byte <span class="cov0" title="0">{
        h := sha256.New()
        h.Write(data)
        h.Write([]byte(key))
        return h.Sum(nil)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/pkg/compress"
        "go.uber.org/zap"
        "net/http"
        "strings"
)

func Gzip(h http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ow := w
                acceptEncoding := r.Header.Get("Accept-Encoding")
                if strings.Contains(acceptEncoding, "gzip") </span><span class="cov8" title="1">{
                        cw := compress.NewCompressWriter(w)
                        ow = cw
                        defer func() </span><span class="cov8" title="1">{
                                if err := cw.Close(); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error close compress writer", zap.Error(err))
                                }</span>
                        }()
                }

                <span class="cov8" title="1">contentEncoding := r.Header.Get("Content-Encoding")
                if strings.Contains(contentEncoding, "gzip") </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if err := r.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error close body", zap.Error(err))
                                }</span>
                        }()

                        <span class="cov8" title="1">cr, err := compress.NewCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("error init compress reader", zap.Error(err))
                                ow.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">r.Body = cr
                        defer func() </span><span class="cov8" title="1">{
                                if err := cr.Close(); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error close compress reader", zap.Error(err))
                                }</span>
                        }()
                }

                <span class="cov8" title="1">h.ServeHTTP(ow, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "bytes"
        "encoding/base64"
        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/pkg/hash"
        "go.uber.org/zap"
        "io"
        "net/http"
)

type (
        hashResponseWriter struct {
                http.ResponseWriter
                Key        string
                HashSHA256 string
                statusCode int
                written    bool
        }
)

func Hash(key string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        hEnc := r.Header.Get("HashSHA256")
                        if hEnc != "" </span><span class="cov0" title="0">{
                                hashA, err := base64.StdEncoding.DecodeString(hEnc)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error decode hash from base64 string", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return
                                }</span>

                                <span class="cov0" title="0">var buf bytes.Buffer
                                tee := io.TeeReader(r.Body, &amp;buf)

                                defer func() </span><span class="cov0" title="0">{
                                        if err := r.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Error("error close reader body", zap.Error(err))
                                        }</span>
                                }()

                                <span class="cov0" title="0">body, err := io.ReadAll(tee)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error read request body", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return
                                }</span>

                                <span class="cov0" title="0">hashB := hash.GetHashSHA256(key, body)
                                if !bytes.Equal(hashA, hashB) </span><span class="cov0" title="0">{
                                        logger.Log.Error("hashes don't match")
                                        w.WriteHeader(http.StatusBadRequest)
                                        return
                                }</span>

                                <span class="cov0" title="0">r.Body = io.NopCloser(&amp;buf)
                                defer func() </span><span class="cov0" title="0">{
                                        if err := r.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Error("error close reader body", zap.Error(err))
                                        }</span>
                                }()
                        }

                        <span class="cov0" title="0">hashRW := hashResponseWriter{
                                ResponseWriter: w,
                                Key:            key,
                        }
                        next.ServeHTTP(hashRW, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "github.com/Vidkin/metrics/internal/logger"
        "go.uber.org/zap"
        "net/http"
        "time"
)

type (
        loggingResponseData struct {
                status int
                size   int
        }

        loggingResponseWriter struct {
                http.ResponseWriter
                responseData *loggingResponseData
        }
)

func (rw *loggingResponseWriter) Write(data []byte) (int, error) <span class="cov8" title="1">{
        size, err := rw.ResponseWriter.Write(data)
        rw.responseData.size += size
        return size, err
}</span>

func (rw *loggingResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        rw.ResponseWriter.WriteHeader(statusCode)
        rw.responseData.status = statusCode
}</span>

func Logging(h http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                startTime := time.Now()
                rData := &amp;loggingResponseData{
                        status: 0,
                        size:   0,
                }
                loggingRW := loggingResponseWriter{
                        responseData:   rData,
                        ResponseWriter: rw,
                }
                h.ServeHTTP(&amp;loggingRW, req)
                duration := time.Since(startTime)

                logger.Log.Info(
                        "Request data",
                        zap.String("method", req.Method),
                        zap.String("URI", req.RequestURI),
                        zap.Duration("duration", duration),
                )

                logger.Log.Info(
                        "Response data",
                        zap.Int("status", rData.status),
                        zap.Int("size", rData.size),
                )
        }</span>)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
