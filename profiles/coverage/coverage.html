
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Vidkin/metrics/app/server.go (89.9%)</option>
				
				<option value="file1">github.com/Vidkin/metrics/cmd/agent/main.go (0.0%)</option>
				
				<option value="file2">github.com/Vidkin/metrics/cmd/server/main.go (0.0%)</option>
				
				<option value="file3">github.com/Vidkin/metrics/cmd/staticlint/multichecker.go (0.0%)</option>
				
				<option value="file4">github.com/Vidkin/metrics/internal/agent/worker.go (54.3%)</option>
				
				<option value="file5">github.com/Vidkin/metrics/internal/config/agent_config.go (0.0%)</option>
				
				<option value="file6">github.com/Vidkin/metrics/internal/config/interval.go (80.0%)</option>
				
				<option value="file7">github.com/Vidkin/metrics/internal/config/server_address.go (0.0%)</option>
				
				<option value="file8">github.com/Vidkin/metrics/internal/config/server_config.go (0.0%)</option>
				
				<option value="file9">github.com/Vidkin/metrics/internal/logger/logger.go (90.9%)</option>
				
				<option value="file10">github.com/Vidkin/metrics/internal/metric/metric.go (100.0%)</option>
				
				<option value="file11">github.com/Vidkin/metrics/internal/proto/metrics.go (83.1%)</option>
				
				<option value="file12">github.com/Vidkin/metrics/internal/repository/mock/mock_repository.go (84.0%)</option>
				
				<option value="file13">github.com/Vidkin/metrics/internal/repository/storage/file.go (81.8%)</option>
				
				<option value="file14">github.com/Vidkin/metrics/internal/repository/storage/memory.go (93.3%)</option>
				
				<option value="file15">github.com/Vidkin/metrics/internal/repository/storage/postgres.go (71.1%)</option>
				
				<option value="file16">github.com/Vidkin/metrics/internal/router/metric_router.go (91.6%)</option>
				
				<option value="file17">github.com/Vidkin/metrics/internal/router/storage_factory.go (81.7%)</option>
				
				<option value="file18">github.com/Vidkin/metrics/pkg/cert/x509.go (83.9%)</option>
				
				<option value="file19">github.com/Vidkin/metrics/pkg/compress/gzip.go (80.0%)</option>
				
				<option value="file20">github.com/Vidkin/metrics/pkg/exitcheck/exit.go (100.0%)</option>
				
				<option value="file21">github.com/Vidkin/metrics/pkg/hash/sha256.go (100.0%)</option>
				
				<option value="file22">github.com/Vidkin/metrics/pkg/interceptors/hash.go (80.8%)</option>
				
				<option value="file23">github.com/Vidkin/metrics/pkg/interceptors/logging.go (92.3%)</option>
				
				<option value="file24">github.com/Vidkin/metrics/pkg/interceptors/trusted_subnet.go (73.9%)</option>
				
				<option value="file25">github.com/Vidkin/metrics/pkg/ip/interfaces.go (75.0%)</option>
				
				<option value="file26">github.com/Vidkin/metrics/pkg/middleware/gzip.go (75.0%)</option>
				
				<option value="file27">github.com/Vidkin/metrics/pkg/middleware/hash.go (75.8%)</option>
				
				<option value="file28">github.com/Vidkin/metrics/pkg/middleware/logging.go (100.0%)</option>
				
				<option value="file29">github.com/Vidkin/metrics/pkg/middleware/trusted_subnet.go (100.0%)</option>
				
				<option value="file30">github.com/Vidkin/metrics/proto/metrics.pb.go (40.3%)</option>
				
				<option value="file31">github.com/Vidkin/metrics/proto/metrics_grpc.pb.go (85.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package app provides an implementation of a server app for handling metrics.
package app

import (
        "context"
        "errors"
        "net"
        "net/http"
        _ "net/http/pprof"
        "os"
        "os/signal"
        "path"
        "syscall"
        "time"

        "github.com/go-chi/chi/v5"
        "go.uber.org/zap"
        "google.golang.org/grpc"

        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        proto2 "github.com/Vidkin/metrics/internal/proto"
        "github.com/Vidkin/metrics/internal/repository/storage"
        "github.com/Vidkin/metrics/internal/router"
        "github.com/Vidkin/metrics/pkg/interceptors"
        "github.com/Vidkin/metrics/proto"
)

type ServerApp struct {
        config     *config.ServerConfig
        srv        *http.Server
        gRPCServer *grpc.Server
        repository router.Repository
}

func NewServerApp(cfg *config.ServerConfig) (*ServerApp, error) <span class="cov8" title="1">{
        if err := logger.Initialize(cfg.LogLevel); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">repo, err := router.NewRepository(cfg)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">serverApp := &amp;ServerApp{
                config:     cfg,
                repository: repo,
        }

        if cfg.UseGRPC </span><span class="cov8" title="1">{
                var s *grpc.Server
                s = grpc.NewServer(
                        grpc.ChainUnaryInterceptor(
                                interceptors.LoggingInterceptor,
                                interceptors.TrustedSubnetInterceptor(cfg.TrustedSubnet),
                                interceptors.HashInterceptor(cfg.Key)))
                proto.RegisterMetricsServer(s, &amp;proto2.MetricsServer{
                        Repository:    repo,
                        LastStoreTime: time.Now(),
                        StoreInterval: (int)(cfg.StoreInterval),
                        RetryCount:    cfg.RetryCount,
                })
                serverApp.gRPCServer = s
        }</span> else<span class="cov8" title="1"> {
                chiRouter := chi.NewRouter()
                metricRouter := router.NewMetricRouter(chiRouter, repo, cfg)
                serverApp.srv = &amp;http.Server{
                        Addr:    cfg.ServerAddress.Address,
                        Handler: metricRouter.Router,
                }
        }</span>

        <span class="cov8" title="1">return serverApp, nil</span>
}

func (a *ServerApp) Serve() <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                err := http.ListenAndServe("localhost:6060", nil)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Log.Error("error start pprof endpoint", zap.Error(err))
                }</span>
        }()
        <span class="cov8" title="1">if a.config.UseGRPC </span><span class="cov8" title="1">{
                listen, err := net.Listen("tcp", a.config.ServerAddress.Address)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal("listen gRPC server fatal error", zap.Error(err))
                }</span>
                // получаем запрос gRPC
                <span class="cov8" title="1">if err := a.gRPCServer.Serve(listen); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal("serve gRPC server fatal error", zap.Error(err))
                }</span>
        } else<span class="cov8" title="1"> {
                if a.config.CryptoKey != "" </span><span class="cov0" title="0">{
                        if err := a.srv.ListenAndServeTLS(path.Join(a.config.CryptoKey, "cert.pem"), path.Join(a.config.CryptoKey, "privateKey.pem")); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                logger.Log.Fatal("listen and serve tls fatal error", zap.Error(err))
                        }</span>
                } else<span class="cov8" title="1"> {
                        if err := a.srv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                                logger.Log.Fatal("listen and serve fatal error", zap.Error(err))
                        }</span>
                }
        }
}

func (a *ServerApp) DumpToFile() error <span class="cov8" title="1">{
        if dumper, ok := a.repository.(router.Dumper); ok </span><span class="cov8" title="1">{
                for i := 0; i &lt;= a.config.RetryCount; i++ </span><span class="cov8" title="1">{
                        err := dumper.FullDump()
                        if err != nil </span><span class="cov8" title="1">{
                                var pathErr *os.PathError
                                if errors.As(err, &amp;pathErr) &amp;&amp; i != a.config.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                                <span class="cov8" title="1">logger.Log.Info("error saving metrics", zap.Error(err))</span>
                        } else<span class="cov8" title="1"> {
                                return nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return errors.New("provided Repository does not implement Dumper")</span>
}

func (a *ServerApp) Run() <span class="cov8" title="1">{
        logger.Log.Info("running server", zap.String("address", a.config.ServerAddress.Address))

        go a.Serve()
        if a.config.StoreInterval &gt; 0 </span><span class="cov8" title="1">{
                ticker := time.NewTicker(time.Duration(a.config.StoreInterval) * time.Second)
                go func() </span><span class="cov8" title="1">{
                        for range ticker.C </span><span class="cov8" title="1">{
                                if err := a.DumpToFile(); err != nil </span><span class="cov8" title="1">{
                                        logger.Log.Info("error interval dump", zap.Error(err))
                                }</span>
                        }
                }()
        }

        <span class="cov8" title="1">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
        &lt;-quit

        defer a.Stop()</span>
}

func (a *ServerApp) Stop() <span class="cov8" title="1">{
        logger.Log.Info("stop server", zap.String("address", a.config.ServerAddress.Address))
        // Создаем контекст с таймаутом для корректного завершения сервера
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Останавливаем сервер, ожидая завершения текущих обработчиков
        if a.gRPCServer != nil </span><span class="cov8" title="1">{
                a.gRPCServer.GracefulStop()
        }</span>
        <span class="cov8" title="1">if a.srv != nil </span><span class="cov8" title="1">{
                if err := a.srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("shutdown error", zap.Error(err))
                }</span>
        }

        <span class="cov8" title="1">logger.Log.Info("dump metrics before exit")
        if _, ok := a.repository.(*storage.FileStorage); ok </span><span class="cov8" title="1">{
                if err := a.DumpToFile(); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error dump metrics before exit", zap.Error(err))
                }</span>
        }
        <span class="cov8" title="1">err := router.Close(a.repository)
        if err != nil </span><span class="cov8" title="1">{
                logger.Log.Info("error close repository before exit", zap.Error(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "os/signal"
        "path"
        "runtime"
        "sync"
        "syscall"

        "github.com/go-resty/resty/v2"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "github.com/Vidkin/metrics/internal/agent"
        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/internal/router"
        "github.com/Vidkin/metrics/proto"
)

var (
        buildVersion = "N/A"
        buildDate    = "N/A"
        buildCommit  = "N/A"
)

func main() <span class="cov0" title="0">{
        fmt.Printf("Build version: %s\nBuild date: %s\nBuild commit: %s\n", buildVersion, buildDate, buildCommit)
        agentConfig, err := config.NewAgentConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">if err = logger.Initialize(agentConfig.LogLevel); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">memoryStorage := router.NewFileStorage("")
        memStats := &amp;runtime.MemStats{}

        var mw *agent.MetricWorker
        if !agentConfig.UseGRPC </span><span class="cov0" title="0">{
                client := resty.New()
                if agentConfig.CryptoKey != "" </span><span class="cov0" title="0">{
                        client.SetRootCertificate(path.Join(agentConfig.CryptoKey, "cert.pem"))
                }</span>
                <span class="cov0" title="0">client.SetDoNotParseResponse(true)
                mw = agent.New(memoryStorage, memStats, client, nil, agentConfig)</span>
        } else<span class="cov0" title="0"> {
                conn, err := grpc.NewClient(agentConfig.ServerAddress.Address, grpc.WithTransportCredentials(insecure.NewCredentials()))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal("error create grpc conn", zap.Error(err))
                }</span>
                <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                        err := conn.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("error close grpc conn", zap.Error(err))
                        }</span>
                }(conn)
                <span class="cov0" title="0">clientGRPC := proto.NewMetricsClient(conn)
                mw = agent.New(memoryStorage, memStats, nil, clientGRPC, agentConfig)</span>
        }

        <span class="cov0" title="0">ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGINT)
        defer stop()

        var wg sync.WaitGroup
        wg.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                mw.Poll(ctx)
        }</span>()

        <span class="cov0" title="0">wg.Wait()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"

        "github.com/Vidkin/metrics/app"
        "github.com/Vidkin/metrics/internal/config"
)

var (
        buildVersion = "N/A"
        buildDate    = "N/A"
        buildCommit  = "N/A"
)

func main() <span class="cov0" title="0">{
        fmt.Printf("Build version: %s\nBuild date: %s\nBuild commit: %s\n", buildVersion, buildDate, buildCommit)
        cfg, err := config.NewServerConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">serverApp, err := app.NewServerApp(cfg)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">serverApp.Run()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Package staticlint provides a command-line tool that runs a collection of static analysis checks on Go code.

The tool includes checks for common programming mistakes, performance issues, and adherence to best practices.

## Usage

To use the staticlint tool, run the following command in your terminal:

        go run /path/to/multichecker.go /path/to/your/package

This will execute all the configured static analysis checks on the Go code in the current directory.

To get more information about the used code analyzers, run the following command in your terminal:

        go run /path/to/multichecker.go --help

## Exit Codes

The staticlint tool will return a non-zero exit code if any of the checks fail, allowing for integration
with CI/CD pipelines and other automated systems.

## Example

To run staticlint on a specific package, you can specify the package path:

        go run path/to/multichecker.go /path/to/package

This will analyze the specified package and report any issues found.

You can specify the analyzers you want to run, for example:

        go run path/to/multichecker.go -ST1006 /path/to/package
*/
package main

import (
        "strings"

        "github.com/gostaticanalysis/nilerr"
        "github.com/orijtech/structslop"
        "golang.org/x/tools/go/analysis"
        "golang.org/x/tools/go/analysis/multichecker"
        "golang.org/x/tools/go/analysis/passes/asmdecl"
        "golang.org/x/tools/go/analysis/passes/assign"
        "golang.org/x/tools/go/analysis/passes/atomic"
        "golang.org/x/tools/go/analysis/passes/atomicalign"
        "golang.org/x/tools/go/analysis/passes/bools"
        "golang.org/x/tools/go/analysis/passes/buildssa"
        "golang.org/x/tools/go/analysis/passes/buildtag"
        "golang.org/x/tools/go/analysis/passes/cgocall"
        "golang.org/x/tools/go/analysis/passes/composite"
        "golang.org/x/tools/go/analysis/passes/copylock"
        "golang.org/x/tools/go/analysis/passes/ctrlflow"
        "golang.org/x/tools/go/analysis/passes/deepequalerrors"
        "golang.org/x/tools/go/analysis/passes/defers"
        "golang.org/x/tools/go/analysis/passes/directive"
        "golang.org/x/tools/go/analysis/passes/errorsas"
        "golang.org/x/tools/go/analysis/passes/fieldalignment"
        "golang.org/x/tools/go/analysis/passes/findcall"
        "golang.org/x/tools/go/analysis/passes/framepointer"
        "golang.org/x/tools/go/analysis/passes/httpresponse"
        "golang.org/x/tools/go/analysis/passes/ifaceassert"
        "golang.org/x/tools/go/analysis/passes/inspect"
        "golang.org/x/tools/go/analysis/passes/loopclosure"
        "golang.org/x/tools/go/analysis/passes/lostcancel"
        "golang.org/x/tools/go/analysis/passes/nilfunc"
        "golang.org/x/tools/go/analysis/passes/nilness"
        "golang.org/x/tools/go/analysis/passes/pkgfact"
        "golang.org/x/tools/go/analysis/passes/printf"
        "golang.org/x/tools/go/analysis/passes/reflectvaluecompare"
        "golang.org/x/tools/go/analysis/passes/shadow"
        "golang.org/x/tools/go/analysis/passes/shift"
        "golang.org/x/tools/go/analysis/passes/sigchanyzer"
        "golang.org/x/tools/go/analysis/passes/slog"
        "golang.org/x/tools/go/analysis/passes/sortslice"
        "golang.org/x/tools/go/analysis/passes/stdmethods"
        "golang.org/x/tools/go/analysis/passes/stringintconv"
        "golang.org/x/tools/go/analysis/passes/structtag"
        "golang.org/x/tools/go/analysis/passes/testinggoroutine"
        "golang.org/x/tools/go/analysis/passes/tests"
        "golang.org/x/tools/go/analysis/passes/timeformat"
        "golang.org/x/tools/go/analysis/passes/unmarshal"
        "golang.org/x/tools/go/analysis/passes/unreachable"
        "golang.org/x/tools/go/analysis/passes/unsafeptr"
        "golang.org/x/tools/go/analysis/passes/unusedresult"
        "golang.org/x/tools/go/analysis/passes/unusedwrite"
        "golang.org/x/tools/go/analysis/passes/usesgenerics"
        "honnef.co/go/tools/staticcheck"
        "honnef.co/go/tools/stylecheck"

        analysis2 "github.com/Vidkin/metrics/pkg/exitcheck"
)

const (
        AnalyzerReceiverNames     = "ST1006"
        AnalyzerErrorShouldBeLast = "ST1008"
)

func getStaticCheckAnalizers() []*analysis.Analyzer <span class="cov0" title="0">{
        var checks []*analysis.Analyzer
        for _, v := range staticcheck.Analyzers </span><span class="cov0" title="0">{
                if strings.HasPrefix(v.Analyzer.Name, "SA") </span><span class="cov0" title="0">{
                        checks = append(checks, v.Analyzer)
                }</span>
        }
        <span class="cov0" title="0">for _, v := range stylecheck.Analyzers </span><span class="cov0" title="0">{
                if v.Analyzer.Name == AnalyzerReceiverNames || v.Analyzer.Name == AnalyzerErrorShouldBeLast </span><span class="cov0" title="0">{
                        checks = append(checks, v.Analyzer)
                }</span>
        }
        <span class="cov0" title="0">return checks</span>
}

func getAnalysisAnalizers() []*analysis.Analyzer <span class="cov0" title="0">{
        res := make([]*analysis.Analyzer, 45)
        res[0] = asmdecl.Analyzer
        res[1] = assign.Analyzer
        res[2] = atomic.Analyzer
        res[3] = atomicalign.Analyzer
        res[4] = bools.Analyzer
        res[5] = buildssa.Analyzer
        res[6] = buildtag.Analyzer
        res[7] = cgocall.Analyzer
        res[8] = composite.Analyzer
        res[9] = copylock.Analyzer
        res[10] = ctrlflow.Analyzer
        res[11] = deepequalerrors.Analyzer
        res[12] = defers.Analyzer
        res[13] = directive.Analyzer
        res[14] = errorsas.Analyzer
        res[15] = fieldalignment.Analyzer
        res[16] = findcall.Analyzer
        res[17] = framepointer.Analyzer
        res[18] = httpresponse.Analyzer
        res[19] = ifaceassert.Analyzer
        res[20] = inspect.Analyzer
        res[21] = loopclosure.Analyzer
        res[22] = lostcancel.Analyzer
        res[23] = nilfunc.Analyzer
        res[24] = nilness.Analyzer
        res[25] = pkgfact.Analyzer
        res[26] = printf.Analyzer
        res[27] = reflectvaluecompare.Analyzer
        res[28] = shadow.Analyzer
        res[29] = shift.Analyzer
        res[30] = sigchanyzer.Analyzer
        res[31] = slog.Analyzer
        res[32] = sortslice.Analyzer
        res[33] = stdmethods.Analyzer
        res[34] = stringintconv.Analyzer
        res[35] = structtag.Analyzer
        res[36] = testinggoroutine.Analyzer
        res[37] = tests.Analyzer
        res[38] = timeformat.Analyzer
        res[39] = unmarshal.Analyzer
        res[40] = unreachable.Analyzer
        res[41] = unsafeptr.Analyzer
        res[42] = unusedresult.Analyzer
        res[43] = unusedwrite.Analyzer
        res[44] = usesgenerics.Analyzer

        return res
}</span>

// main is the entry point of the staticlint tool. It initializes and runs a collection of static analysis checks
// on Go code. Need to build with flag: -ldflags=-checklinkname=0 cause of structslop.Analyzer
func main() <span class="cov0" title="0">{
        allChecks := make([]*analysis.Analyzer, 0)
        allChecks = append(allChecks, analysis2.ExitMainAnalyzer)
        allChecks = append(allChecks, structslop.Analyzer)
        allChecks = append(allChecks, nilerr.Analyzer)
        allChecks = append(allChecks, getAnalysisAnalizers()...)
        allChecks = append(allChecks, getStaticCheckAnalizers()...)
        multichecker.Main(
                allChecks...,
        )
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package agent provides functionality for collecting and sending metrics from the agent to a server.
package agent

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "errors"
        "io"
        "math/rand/v2"
        "net/url"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/go-resty/resty/v2"
        "github.com/shirou/gopsutil/cpu"
        "github.com/shirou/gopsutil/mem"
        "go.uber.org/zap"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        pb "google.golang.org/protobuf/proto"

        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/internal/metric"
        "github.com/Vidkin/metrics/internal/router"
        "github.com/Vidkin/metrics/pkg/hash"
        "github.com/Vidkin/metrics/pkg/ip"
        "github.com/Vidkin/metrics/proto"
)

const (
        GaugeMetricAlloc          = "Alloc"
        GaugeMetricBuckHashSys    = "BuckHashSys"
        GaugeMetricFrees          = "Frees"
        GaugeMetricGCCPUFraction  = "GCCPUFraction"
        GaugeMetricGCSys          = "GCSys"
        GaugeMetricHeapAlloc      = "HeapAlloc"
        GaugeMetricHeapIdle       = "HeapIdle"
        GaugeMetricHeapInuse      = "HeapInuse"
        GaugeMetricHeapObjects    = "HeapObjects"
        GaugeMetricHeapReleased   = "HeapReleased"
        GaugeMetricHeapSys        = "HeapSys"
        GaugeMetricLastGC         = "LastGC"
        GaugeMetricLookups        = "Lookups"
        GaugeMetricMCacheInuse    = "MCacheInuse"
        GaugeMetricMCacheSys      = "MCacheSys"
        GaugeMetricMSpanInuse     = "MSpanInuse"
        GaugeMetricMSpanSys       = "MSpanSys"
        GaugeMetricMallocs        = "Mallocs"
        GaugeMetricNextGC         = "NextGC"
        GaugeMetricNumForcedGC    = "NumForcedGC"
        GaugeMetricNumGC          = "NumGC"
        GaugeMetricOtherSys       = "OtherSys"
        GaugeMetricPauseTotalNs   = "PauseTotalNs"
        GaugeMetricStackInuse     = "StackInuse"
        GaugeMetricStackSys       = "StackSys"
        GaugeMetricSys            = "Sys"
        GaugeMetricTotalAlloc     = "TotalAlloc"
        GaugeMetricRandomValue    = "RandomValue"
        GaugeMetricTotalMemory    = "TotalMemory"
        GaugeMetricFreeMemory     = "FreeMemory"
        GaugeMetricCPUutilization = "CPUutilization"

        CounterMetricPollCount = "PollCount"

        MetricTypeCounter = "counter"
        MetricTypeGauge   = "gauge"

        RequestRetryCount = 3
)

type MetricWorker struct {
        repository router.Repository
        memStats   *runtime.MemStats
        client     *resty.Client
        clientGRPC proto.MetricsClient
        config     *config.AgentConfig
}

func New(repository router.Repository, memStats *runtime.MemStats, client *resty.Client, clientGRPC proto.MetricsClient, config *config.AgentConfig) *MetricWorker <span class="cov8" title="1">{
        return &amp;MetricWorker{
                repository: repository,
                memStats:   memStats,
                client:     client,
                clientGRPC: clientGRPC,
                config:     config,
        }
}</span>

func (mw *MetricWorker) CollectMetrics(ctx context.Context, chIn chan []*metric.Metric, count int64) <span class="cov8" title="1">{
        defer close(chIn)
        runtime.ReadMemStats(mw.memStats)

        vmStat, err := mem.VirtualMemory()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error collect memory metrics", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">totalMemory := vmStat.Total / 1024 / 1024
        freeMemory := vmStat.Free / 1024 / 1024

        percentages, err := cpu.Percent(0, true)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error collect cpu utilization metrics", zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">gaugeMetrics := map[string]float64{
                GaugeMetricAlloc:         float64(mw.memStats.Alloc),
                GaugeMetricBuckHashSys:   float64(mw.memStats.BuckHashSys),
                GaugeMetricFrees:         float64(mw.memStats.Frees),
                GaugeMetricMCacheSys:     float64(mw.memStats.MCacheSys),
                GaugeMetricMSpanInuse:    float64(mw.memStats.MSpanInuse),
                GaugeMetricNumForcedGC:   float64(mw.memStats.NumForcedGC),
                GaugeMetricGCCPUFraction: mw.memStats.GCCPUFraction,
                GaugeMetricGCSys:         float64(mw.memStats.GCSys),
                GaugeMetricHeapAlloc:     float64(mw.memStats.HeapAlloc),
                GaugeMetricHeapIdle:      float64(mw.memStats.HeapIdle),
                GaugeMetricHeapInuse:     float64(mw.memStats.HeapInuse),
                GaugeMetricHeapObjects:   float64(mw.memStats.HeapObjects),
                GaugeMetricHeapReleased:  float64(mw.memStats.HeapReleased),
                GaugeMetricHeapSys:       float64(mw.memStats.HeapSys),
                GaugeMetricLastGC:        float64(mw.memStats.LastGC),
                GaugeMetricLookups:       float64(mw.memStats.Lookups),
                GaugeMetricMCacheInuse:   float64(mw.memStats.MCacheInuse),
                GaugeMetricMSpanSys:      float64(mw.memStats.MSpanSys),
                GaugeMetricMallocs:       float64(mw.memStats.Mallocs),
                GaugeMetricNextGC:        float64(mw.memStats.NextGC),
                GaugeMetricNumGC:         float64(mw.memStats.NumGC),
                GaugeMetricOtherSys:      float64(mw.memStats.OtherSys),
                GaugeMetricPauseTotalNs:  float64(mw.memStats.PauseTotalNs),
                GaugeMetricStackInuse:    float64(mw.memStats.StackInuse),
                GaugeMetricStackSys:      float64(mw.memStats.StackSys),
                GaugeMetricSys:           float64(mw.memStats.Sys),
                GaugeMetricTotalAlloc:    float64(mw.memStats.TotalAlloc),
                GaugeMetricTotalMemory:   float64(totalMemory),
                GaugeMetricFreeMemory:    float64(freeMemory),
                GaugeMetricRandomValue:   rand.Float64(),
        }
        for i, percentage := range percentages </span><span class="cov8" title="1">{
                gaugeMetrics[GaugeMetricCPUutilization+strconv.Itoa(i+1)] = percentage
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(ctx, 2*time.Second)
        defer cancel()
        for k, v := range gaugeMetrics </span><span class="cov8" title="1">{
                gMetric := &amp;metric.Metric{
                        ID:    k,
                        MType: MetricTypeGauge,
                        Value: &amp;v,
                }
                err = mw.repository.UpdateMetric(ctx, gMetric)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error update gauge metric", zap.Error(err))
                        return
                }</span>
        }
        <span class="cov8" title="1">cMetric := &amp;metric.Metric{
                ID:    CounterMetricPollCount,
                MType: MetricTypeCounter,
                Delta: &amp;count,
        }
        err = mw.repository.UpdateMetric(ctx, cMetric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error update counter metric", zap.Error(err))
                return
        }</span>

        <span class="cov8" title="1">metrics, err := mw.repository.GetMetrics(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error get metrics from repository", zap.Error(err))
                return
        }</span>
        <span class="cov8" title="1">chIn &lt;- metrics</span>
}

func (mw *MetricWorker) SendMetric(ctx context.Context, url string, metric *metric.Metric) (int, string, error) <span class="cov8" title="1">{
        body, err := json.Marshal(metric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal body", zap.Error(err))
                return 0, "", err
        }</span>

        <span class="cov8" title="1">buf := bytes.NewBuffer(nil)
        zb := gzip.NewWriter(buf)
        _, err = zb.Write(body)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error gzip body", zap.Error(err))
                return 0, "", err
        }</span>

        <span class="cov8" title="1">err = zb.Close()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error close gzip buffer", zap.Error(err))
                return 0, "", err
        }</span>

        <span class="cov8" title="1">interfaces, err := ip.GetMyInterfaces()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get net interfaces", zap.Error(err))
                return 0, "", err
        }</span>
        <span class="cov8" title="1">if len(interfaces) == 0 </span><span class="cov0" title="0">{
                logger.Log.Info("error get net interfaces")
                return 0, "", errors.New("error get net interfaces")
        }</span>

        <span class="cov8" title="1">req := mw.client.R().
                SetHeader("Content-Type", "application/json").
                SetHeader("Content-Encoding", "gzip").
                SetHeader("Accept-Encoding", "gzip").
                SetHeader("X-Real-IP", interfaces[0]).
                SetBody(buf)

        resp, err := req.SetContext(ctx).Post(url)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error post request", zap.Error(err))
                return 0, "", err
        }</span>
        <span class="cov8" title="1">defer func(body io.ReadCloser) </span><span class="cov8" title="1">{
                err = body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error close resp raw body", zap.Error(err))
                }</span>
        }(resp.RawBody())

        <span class="cov8" title="1">contentEncoding := resp.Header().Get("Content-Encoding")
        var or io.ReadCloser
        if strings.Contains(contentEncoding, "gzip") </span><span class="cov8" title="1">{
                var cr *gzip.Reader
                cr, err = gzip.NewReader(resp.RawBody())
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error init gzip reader", zap.Error(err))
                        return 0, "", err
                }</span>
                <span class="cov8" title="1">or = cr</span>
        } else<span class="cov8" title="1"> {
                or = resp.RawBody()
        }</span>

        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                logger.Log.Info("SendMetric shutdown due to context cancellation")
                return 0, "", ctx.Err()</span> // Возвращаем ошибку отмены контекста
        default:<span class="cov8" title="1">
                respBody, err := io.ReadAll(or)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error read response body", zap.Error(err))
                        return 0, "", err
                }</span>
                <span class="cov8" title="1">return resp.StatusCode(), string(respBody), nil</span>
        }
}

func (mw *MetricWorker) SendMetricsGRPC(ctx context.Context, chIn chan []*metric.Metric) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case m, ok := &lt;-chIn:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">protoMetrics := make([]*proto.Metric, len(m))
                        for i, met := range m </span><span class="cov8" title="1">{
                                protoMetrics[i] = &amp;proto.Metric{
                                        Id: met.ID,
                                }
                                if met.MType == MetricTypeCounter </span><span class="cov8" title="1">{
                                        protoMetrics[i].Delta = *met.Delta
                                        protoMetrics[i].Type = proto.Metric_COUNTER
                                }</span> else<span class="cov8" title="1"> {
                                        protoMetrics[i].Value = *met.Value
                                        protoMetrics[i].Type = proto.Metric_GAUGE
                                }</span>
                        }

                        <span class="cov8" title="1">for i := 0; i &lt;= RequestRetryCount; i++ </span><span class="cov8" title="1">{
                                ctxTimeout, cancel := context.WithTimeout(ctx, 200*time.Millisecond)
                                defer cancel()

                                req := &amp;proto.UpdateMetricsRequest{
                                        Metrics: protoMetrics,
                                }

                                if mw.config.Key != "" </span><span class="cov8" title="1">{
                                        data, err := pb.Marshal(req)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Error("failed to marshal request: %v", zap.Error(err))
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">h := hash.GetHashSHA256(mw.config.Key, data)
                                        hEnc := base64.StdEncoding.EncodeToString(h)
                                        md := metadata.New(map[string]string{"HashSHA256": hEnc})
                                        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
                                }

                                <span class="cov8" title="1">_, err := mw.clientGRPC.UpdateMetrics(ctxTimeout, req)
                                if err != nil </span><span class="cov8" title="1">{
                                        if e, ok := status.FromError(err); ok </span><span class="cov8" title="1">{
                                                logger.Log.Error("code = " + e.Code().String() + ", message = " + e.Message())
                                        }</span> else<span class="cov0" title="0"> {
                                                logger.Log.Error("error update metrics", zap.Error(err))
                                        }</span>

                                        <span class="cov8" title="1">if i != RequestRetryCount </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                }
                                <span class="cov8" title="1">break</span>
                        }

                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (mw *MetricWorker) SendMetrics(ctx context.Context, chIn chan []*metric.Metric, serverURL string) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case m, ok := &lt;-chIn:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">body, _ := json.Marshal(m)
                        buf := bytes.NewBuffer([]byte{})
                        zb := gzip.NewWriter(buf)
                        _, _ = zb.Write(body)
                        err := zb.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Info("error close gzip writer", zap.Error(err))
                        }</span>

                        <span class="cov8" title="1">for i := 0; i &lt;= RequestRetryCount; i++ </span><span class="cov8" title="1">{
                                req := mw.client.R()
                                if mw.config.Key != "" </span><span class="cov0" title="0">{
                                        h := hash.GetHashSHA256(mw.config.Key, buf.Bytes())
                                        hEnc := base64.StdEncoding.EncodeToString(h)
                                        req.SetHeader("HashSHA256", hEnc)
                                }</span>
                                <span class="cov8" title="1">interfaces, err := ip.GetMyInterfaces()
                                if err != nil || len(interfaces) == 0 </span><span class="cov0" title="0">{
                                        logger.Log.Info("error get net interfaces", zap.Error(err))
                                        return
                                }</span>
                                <span class="cov8" title="1">_, err = req.
                                        SetHeader("Content-Type", "application/json").
                                        SetHeader("Content-Encoding", "gzip").
                                        SetHeader("Accept-Encoding", "gzip").
                                        SetHeader("X-Real-IP", interfaces[0]).
                                        SetBody(buf).
                                        Post(serverURL)
                                if err != nil </span><span class="cov0" title="0">{
                                        var urlErr *url.Error
                                        if errors.As(err, &amp;urlErr) &amp;&amp; i != RequestRetryCount </span><span class="cov0" title="0">{
                                                logger.Log.Info("error post request", zap.Error(err))
                                                time.Sleep(time.Duration(1+i*2) * time.Second)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">logger.Log.Info("error post request", zap.Error(err))
                                        return</span>
                                }
                                <span class="cov8" title="1">break</span>
                        }

                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

func (mw *MetricWorker) Poll(ctx context.Context) <span class="cov0" title="0">{
        startTime := time.Now()
        protocol := "http"
        if mw.config.CryptoKey != "" </span><span class="cov0" title="0">{
                protocol = "https"
        }</span>
        <span class="cov0" title="0">var serverURL = protocol + "://" + mw.config.ServerAddress.Address + "/updates/"
        var count int64 = 0

        var wg sync.WaitGroup

        for </span><span class="cov0" title="0">{
                chIn := make(chan []*metric.Metric, mw.config.RateLimit)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.Log.Info("application shutdown")
                        ctxTimeout, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()
                        if !mw.config.UseGRPC </span><span class="cov0" title="0">{
                                mw.SendMetrics(ctxTimeout, chIn, serverURL)
                        }</span> else<span class="cov0" title="0"> {
                                mw.SendMetricsGRPC(ctxTimeout, chIn)
                        }</span>

                        <span class="cov0" title="0">ctxWait, cancelWait := context.WithTimeout(context.Background(), 2*time.Second)
                        defer cancelWait()
                        go func() </span><span class="cov0" title="0">{
                                wg.Wait()
                        }</span>()

                        <span class="cov0" title="0">&lt;-ctxWait.Done()
                        return</span>
                default:<span class="cov0" title="0">
                        currentTime := time.Now()

                        wg.Add(1)
                        go func() </span><span class="cov0" title="0">{
                                defer wg.Done()
                                mw.CollectMetrics(ctx, chIn, count)
                        }</span>()

                        <span class="cov0" title="0">if currentTime.Sub(startTime).Seconds() &gt;= float64(mw.config.ReportInterval) </span><span class="cov0" title="0">{
                                startTime = currentTime
                                for w := 1; w &lt;= mw.config.RateLimit; w++ </span><span class="cov0" title="0">{
                                        wg.Add(1)
                                        go func() </span><span class="cov0" title="0">{
                                                defer wg.Done()
                                                if !mw.config.UseGRPC </span><span class="cov0" title="0">{
                                                        mw.SendMetrics(ctx, chIn, serverURL)
                                                }</span> else<span class="cov0" title="0"> {
                                                        mw.SendMetricsGRPC(ctx, chIn)
                                                }</span>
                                        }()
                                }
                        }
                        <span class="cov0" title="0">time.Sleep(time.Duration(mw.config.PollInterval) * time.Second)
                        count++</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "encoding/json"
        "flag"
        "os"

        "github.com/caarlos0/env/v6"
        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/logger"
)

// Constants for default agent intervals.
//
// DefaultAgentPollInterval specifies the default interval at which the agent
// polls for updates. The default value is set to 2 seconds.
//
// DefaultAgentReportInterval specifies the default interval at which the agent
// reports metrics to the server. The default value is set to 10 seconds.
const (
        DefaultAgentPollInterval   = 2
        DefaultAgentReportInterval = 10
)

// AgentConfig holds the configuration settings for the agent.
//
// This struct is used to manage various parameters that control the behavior
// of the agent, including server connection details, polling intervals, rate
// limits, and logging levels. The configuration can be populated from command-line
// flags and environment variables, allowing for flexible deployment and management
// of the agent's settings.
type AgentConfig struct {
        ServerAddress  *ServerAddress `json:"address"`
        ConfigPath     string         `env:"CONFIG"`
        Key            string         `env:"KEY" json:"hash_key"`
        CryptoKey      string         `env:"CRYPTO_KEY" json:"crypto_key"`
        LogLevel       string
        ReportInterval Interval `env:"REPORT_INTERVAL" json:"report_interval"`
        PollInterval   Interval `env:"POLL_INTERVAL" json:"poll_interval"`
        UseGRPC        bool     `env:"USE_GRPC" json:"use_grpc"`
        RateLimit      int      `env:"RATE_LIMIT" json:"rate_limit"`
}

// NewAgentConfig initializes a new AgentConfig instance with default values
// and parses command-line flags and environment variables to populate its fields.
//
// Returns:
// - A pointer to an `AgentConfig` instance containing the configuration settings.
// - An error if there was an issue during initialization or parsing; otherwise, nil.
func NewAgentConfig() (*AgentConfig, error) <span class="cov0" title="0">{
        var config AgentConfig
        config.ServerAddress = NewServerAddress()
        config.LogLevel = "info"
        err := config.parseFlags()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (config *AgentConfig) parseFlags() error <span class="cov0" title="0">{
        flag.Var(config.ServerAddress, "a", "Server address host:port")
        flag.StringVar(&amp;config.ConfigPath, "c", "", "Path to json config file")
        flag.StringVar(&amp;config.ConfigPath, "config", "", "Path to json config file")
        flag.IntVar((*int)(&amp;config.ReportInterval), "r", DefaultAgentReportInterval, "Agent report poll interval (sec)")
        flag.IntVar((*int)(&amp;config.PollInterval), "p", DefaultAgentPollInterval, "Agent poll interval (sec)")
        flag.IntVar(&amp;config.RateLimit, "l", 5, "Rate limit")
        flag.StringVar(&amp;config.Key, "k", "", "Hash key")
        flag.BoolVar(&amp;config.UseGRPC, "g", true, "Use gRPC")
        flag.StringVar(&amp;config.CryptoKey, "crypto-key", "", "Crypto key")
        flag.Parse()

        if config.ConfigPath != "" </span><span class="cov0" title="0">{
                if err := config.loadJSONConfig(config.ConfigPath); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error parse json config file", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">err := env.Parse(config.ServerAddress)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if config.ServerAddress.Address == "" </span><span class="cov0" title="0">{
                config.ServerAddress.Address = config.ServerAddress.String()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (config *AgentConfig) loadJSONConfig(path string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var jsonAgentConfig AgentConfig
        if err = json.Unmarshal(data, &amp;jsonAgentConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if config.ServerAddress.Address == "" </span><span class="cov0" title="0">{
                config.ServerAddress = jsonAgentConfig.ServerAddress
        }</span>

        <span class="cov0" title="0">cryptoKeyPassed := false
        reportIntervalPassed := false
        pollIntervalPassed := false
        hashKeyPassed := false
        rateLimitPassed := false
        useGRPCPassed := false

        args := os.Args[1:]
        for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                arg := args[i]
                switch arg </span>{
                case "--p", "-p":<span class="cov0" title="0">
                        pollIntervalPassed = true</span>
                case "--crypto-key", "-crypto-key":<span class="cov0" title="0">
                        cryptoKeyPassed = true</span>
                case "--r", "-r":<span class="cov0" title="0">
                        reportIntervalPassed = true</span>
                case "--l", "-l":<span class="cov0" title="0">
                        rateLimitPassed = true</span>
                case "--k", "-k":<span class="cov0" title="0">
                        hashKeyPassed = true</span>
                case "--g", "-g":<span class="cov0" title="0">
                        useGRPCPassed = true</span>
                }
        }

        <span class="cov0" title="0">if !cryptoKeyPassed </span><span class="cov0" title="0">{
                config.CryptoKey = jsonAgentConfig.CryptoKey
        }</span>

        <span class="cov0" title="0">if !useGRPCPassed </span><span class="cov0" title="0">{
                config.UseGRPC = jsonAgentConfig.UseGRPC
        }</span>

        <span class="cov0" title="0">if !reportIntervalPassed </span><span class="cov0" title="0">{
                config.ReportInterval = jsonAgentConfig.ReportInterval
        }</span>

        <span class="cov0" title="0">if !pollIntervalPassed </span><span class="cov0" title="0">{
                config.PollInterval = jsonAgentConfig.PollInterval
        }</span>

        <span class="cov0" title="0">if !rateLimitPassed </span><span class="cov0" title="0">{
                config.RateLimit = jsonAgentConfig.RateLimit
        }</span>

        <span class="cov0" title="0">if !hashKeyPassed </span><span class="cov0" title="0">{
                config.Key = jsonAgentConfig.Key
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
)

// Interval represents a time interval in seconds.
type Interval int

// UnmarshalJSON customizes the JSON unmarshalling for the Interval type.
// It expects a string representation of the interval, which should end with
// the suffix "s" (for seconds). The method converts the string to an integer
// and assigns it to the Interval type.
//
// Returns an error if the input format is invalid or if the conversion fails.
func (i *Interval) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var intervalStr string

        if err := json.Unmarshal(data, &amp;intervalStr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if strings.HasSuffix(intervalStr, "s") </span><span class="cov8" title="1">{
                seconds, err := strconv.Atoi(strings.TrimSuffix(intervalStr, "s"))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*i = Interval(seconds)</span>
        } else<span class="cov8" title="1"> {
                return fmt.Errorf("invalid interval format: %s", intervalStr)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "errors"
        "net"
        "strconv"
        "strings"
)

const (
        DefaultServerAddress = "127.0.0.1"
        DefaultServerPort    = 8080
)

// ServerAddress represents the host and port information for a server.
//
// This struct is used to manage the server's address configuration, including
// the host name or IP address and the port number. It can be initialized with
// default values and can also be populated from environment variables.
type ServerAddress struct {
        Address string `env:"ADDRESS"`
        Host    string
        Port    int
}

// NewServerAddress creates and returns a new instance of the ServerAddress struct
// initialized with default values.
//
// The default host is set to "localhost" and the default port is set to 8080.
// This function is useful for quickly obtaining a ServerAddress instance
// without needing to specify the host and port manually.
//
// Returns:
// - Pointer to the newly created ServerAddress instance.
func NewServerAddress() *ServerAddress <span class="cov0" title="0">{
        return &amp;ServerAddress{
                Host: DefaultServerAddress,
                Port: DefaultServerPort,
        }
}</span>

// String returns the string representation of the ServerAddress in the format "host:port".
//
// Returns:
//   - The server address string formatted as "host:port".
func (s *ServerAddress) String() string <span class="cov0" title="0">{
        return s.Host + ":" + strconv.Itoa(s.Port)
}</span>

// Set updates the Host and Port fields of the ServerAddress struct based on the provided
// address string in the format "host:port".
//
// Parameters:
//   - flagRunAddr: The address string to set, in the format "host:port".
//
// Returns:
//   - An error if the input format is invalid or if the port cannot be converted to an integer.
func (s *ServerAddress) Set(flagRunAddr string) error <span class="cov0" title="0">{
        splittedAddress := strings.Split(flagRunAddr, ":")

        if len(splittedAddress) != 2 </span><span class="cov0" title="0">{
                return errors.New("need address in a form host:port")
        }</span>

        <span class="cov0" title="0">port, err := strconv.Atoi(splittedAddress[1])

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.Host = splittedAddress[0]
        s.Port = port

        return nil</span>
}

// UnmarshalJSON unmarshals a JSON object into a ServerAddress struct.
// It expects the JSON to contain an "address" field in the format "host:port".
//
// Parameters:
//   - data: A byte slice containing the JSON data to unmarshal.
//
// Returns:
//   - An error if the input format is invalid or if the port cannot be converted to an integer.
func (s *ServerAddress) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        address := strings.Trim(string(data), "\"")
        host, portStr, err := net.SplitHostPort(address)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.Host = host
        port, err := strconv.Atoi(portStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.Port = port
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "encoding/json"
        "flag"
        "os"

        "github.com/caarlos0/env/v6"
        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/logger"
)

// ServerConfig holds the configuration settings for the server.
//
// This struct contains various fields that define how the server operates,
// including its address, storage settings, logging preferences, and more.
// The fields can be populated from environment variables, allowing for
// flexible configuration without hardcoding values.
type ServerConfig struct {
        ServerAddress   *ServerAddress `json:"address"`
        LogLevel        string
        TrustedSubnet   string   `evn:"TRUSTED_SUBNET" json:"trusted_subnet"`
        ConfigPath      string   `env:"CONFIG"`
        FileStoragePath string   `env:"FILE_STORAGE_PATH" json:"store_file"`
        DatabaseDSN     string   `env:"DATABASE_DSN" json:"database_dsn"`
        Key             string   `env:"KEY" json:"hash_key"`
        CryptoKey       string   `env:"CRYPTO_KEY" json:"crypto_key"`
        StoreInterval   Interval `env:"STORE_INTERVAL" json:"store_interval"`
        Restore         bool     `env:"RESTORE" json:"restore"`
        UseGRPC         bool     `env:"USER_GRPC" json:"use_grpc"`
        RetryCount      int
}

// NewServerConfig initializes a new ServerConfig instance with default values
// and parses command-line flags and environment variables to populate its fields
//
// Returns:
// - A pointer to the newly created and initialized ServerConfig instance.
// - An error if the configuration parsing fails; otherwise, nil.
func NewServerConfig() (*ServerConfig, error) <span class="cov0" title="0">{
        var config ServerConfig
        config.ServerAddress = NewServerAddress()
        config.RetryCount = 3
        err := config.parseFlags()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (config *ServerConfig) parseFlags() error <span class="cov0" title="0">{
        flag.Var(config.ServerAddress, "a", "Net address host:port")
        flag.StringVar(&amp;config.ConfigPath, "c", "", "Path to json config file")
        flag.StringVar(&amp;config.ConfigPath, "config", "", "Path to json config file")
        flag.StringVar(&amp;config.LogLevel, "l", "info", "Log level")
        flag.IntVar((*int)(&amp;config.StoreInterval), "i", 300, "Config store interval")
        flag.StringVar(&amp;config.FileStoragePath, "f", "", "Metrics file storage path")
        flag.StringVar(&amp;config.DatabaseDSN, "d", "", "Database DSN")
        flag.StringVar(&amp;config.Key, "k", "", "Hash key")
        flag.StringVar(&amp;config.CryptoKey, "crypto-key", "", "Crypto key")
        flag.StringVar(&amp;config.TrustedSubnet, "t", "", "Agent trusted subnet")
        flag.BoolVar(&amp;config.Restore, "r", true, "Restore metrics on startup")
        flag.BoolVar(&amp;config.UseGRPC, "g", true, "Use gRPC")
        flag.Parse()

        if config.ConfigPath != "" </span><span class="cov0" title="0">{
                if err := config.loadJSONConfig(config.ConfigPath); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error parse json config file", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">err := env.Parse(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if config.ServerAddress.Address == "" </span><span class="cov0" title="0">{
                config.ServerAddress.Address = config.ServerAddress.String()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (config *ServerConfig) loadJSONConfig(path string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var jsonServerConfig ServerConfig
        if err = json.Unmarshal(data, &amp;jsonServerConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if config.ServerAddress.Address == "" </span><span class="cov0" title="0">{
                config.ServerAddress = jsonServerConfig.ServerAddress
        }</span>

        <span class="cov0" title="0">storeFilePassed := false
        dbDSNPassed := false
        cryptoKeyPassed := false
        storeIntervalPassed := false
        restorePassed := false
        hashKeyPassed := false
        trustedSubnetPassed := false
        useGRPCPassed := false

        args := os.Args[1:]
        for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                arg := args[i]
                switch arg </span>{
                case "--f", "-f":<span class="cov0" title="0">
                        storeFilePassed = true</span>
                case "--i", "-i":<span class="cov0" title="0">
                        storeIntervalPassed = true</span>
                case "--d", "-d":<span class="cov0" title="0">
                        dbDSNPassed = true</span>
                case "--crypto-key", "-crypto-key":<span class="cov0" title="0">
                        cryptoKeyPassed = true</span>
                case "--r", "-r":<span class="cov0" title="0">
                        restorePassed = true</span>
                case "--k", "-k":<span class="cov0" title="0">
                        hashKeyPassed = true</span>
                case "--g", "-g":<span class="cov0" title="0">
                        useGRPCPassed = true</span>
                case "--t", "-t":<span class="cov0" title="0">
                        trustedSubnetPassed = true</span>
                }
        }

        <span class="cov0" title="0">if !trustedSubnetPassed </span><span class="cov0" title="0">{
                config.TrustedSubnet = jsonServerConfig.TrustedSubnet
        }</span>

        <span class="cov0" title="0">if !useGRPCPassed </span><span class="cov0" title="0">{
                config.UseGRPC = jsonServerConfig.UseGRPC
        }</span>

        <span class="cov0" title="0">if !dbDSNPassed </span><span class="cov0" title="0">{
                config.DatabaseDSN = jsonServerConfig.DatabaseDSN
        }</span>

        <span class="cov0" title="0">if !storeFilePassed </span><span class="cov0" title="0">{
                config.FileStoragePath = jsonServerConfig.FileStoragePath
        }</span>

        <span class="cov0" title="0">if !cryptoKeyPassed </span><span class="cov0" title="0">{
                config.CryptoKey = jsonServerConfig.CryptoKey
        }</span>

        <span class="cov0" title="0">if !storeIntervalPassed </span><span class="cov0" title="0">{
                config.StoreInterval = jsonServerConfig.StoreInterval
        }</span>

        <span class="cov0" title="0">if !restorePassed </span><span class="cov0" title="0">{
                config.Restore = jsonServerConfig.Restore
        }</span>

        <span class="cov0" title="0">if !hashKeyPassed </span><span class="cov0" title="0">{
                config.Key = jsonServerConfig.Key
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package logger provides a simple logging utility using the Zap logging library.
package logger

import (
        "go.uber.org/zap"
)

var Log *zap.Logger = zap.NewNop()

func Initialize(logLevel string) error <span class="cov8" title="1">{
        lvl, err := zap.ParseAtomicLevel(logLevel)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">cfg := zap.NewProductionConfig()
        cfg.Level = lvl

        logger, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer logger.Sync()

        Log = logger
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package metric provides defining of metrics used in monitoring systems.
package metric

import (
        "strconv"
)

// Metric represents a single metric used in monitoring systems.
//
// This struct encapsulates the properties of a metric, including its unique identifier (name),
// type, and value.
type Metric struct {
        Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
        Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
        ID    string   `json:"id"`              // имя метрики
        MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
}

// ValueAsString returns the string representation of the metric's value based on its type.
//
// Returns:
//   - The string representation of the metric's value, formatted according to its type.
func (m *Metric) ValueAsString() string <span class="cov8" title="1">{
        if m.MType == "gauge" </span><span class="cov8" title="1">{
                return strconv.FormatFloat(*m.Value, 'g', -1, 64)
        }</span>
        <span class="cov8" title="1">return strconv.FormatInt(*m.Delta, 10)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package proto provides a gRPC server implementation for handling metrics-related operations.
// It defines the MetricsServer struct and methods for updating and dumping metrics to a repository.
package proto

import (
        "context"
        "errors"
        "os"
        "time"

        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/internal/metric"
        "github.com/Vidkin/metrics/internal/router"
        "github.com/Vidkin/metrics/proto"
)

// MetricsServer is a gRPC server that handles metrics-related operations.
// It implements the proto.MetricsServer interface and provides methods for
// updating and dumping metrics to a specified repository.
type MetricsServer struct {
        proto.UnimplementedMetricsServer
        Repository    router.Repository // Repository for storing metrics
        LastStoreTime time.Time         // Last time metrics were successfully stored
        RetryCount    int               // Number of retry attempts for database operations
        StoreInterval int               // Interval for storing metrics
}

// Dumper defines the methods required for dumping metrics to a storage system.
// Implementations of this interface should provide functionality to save individual metrics
// as well as to perform a complete dump of all metrics.
type Dumper interface {
        Dump(metric *metric.Metric) error // Dumps a single metric
        FullDump() error                  // Performs a complete dump of all metrics
}

// DumpMetric attempts to dump a given metric to the provided Repository.
// It checks if the Repository implements the Dumper interface. If it does,
// the function calls the Dump method of the Dumper interface to persist
// the metric. If the Repository does not implement the Dumper interface,
// the function returns an error indicating that the provided Repository
// cannot perform the dump operation.
//
// Parameters:
//   - r: A Repository instance that is expected to implement the Dumper interface.
//   - m: A pointer to the metric.Metric that needs to be dumped.
//
// Returns:
//   - An error if the dumping operation fails or if the Repository does not
//     implement the Dumper interface; otherwise, it returns nil.
func DumpMetric(r router.Repository, m *metric.Metric) error <span class="cov8" title="1">{
        if dumper, ok := r.(Dumper); ok </span><span class="cov8" title="1">{
                return dumper.Dump(m)
        }</span>
        <span class="cov0" title="0">return errors.New("provided Repository does not implement Dumper")</span>
}

// DumpMetric attempts to dump a given metric to the MetricsServer's Repository.
// It retries the dump operation based on the configured RetryCount and handles
// connection errors by waiting and retrying.
//
// Parameters:
//   - metric: A pointer to the metric.Metric that needs to be dumped.
//
// Returns:
//   - An error if the dumping operation fails; otherwise, it returns nil.
func (m *MetricsServer) DumpMetric(metric *metric.Metric) error <span class="cov8" title="1">{
        if m.StoreInterval == 0 </span><span class="cov8" title="1">{
                for i := 0; i &lt;= m.RetryCount; i++ </span><span class="cov8" title="1">{
                        err := DumpMetric(m.Repository, metric)
                        if err != nil </span><span class="cov8" title="1">{
                                var pathErr *os.PathError
                                if errors.As(err, &amp;pathErr) &amp;&amp; i != m.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                                <span class="cov0" title="0">logger.Log.Info("error saving metric", zap.Error(err))
                                return errors.New("error saving metric")</span>
                        }
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// UpdateMetrics handles the gRPC request to update multiple metrics.
// It processes the incoming UpdateMetricsRequest, updates the metrics in the repository,
// and returns the updated metrics in the response.
//
// Parameters:
//   - ctx: A context.Context to control the lifetime of the operation.
//   - in: A pointer to the proto.UpdateMetricsRequest containing the metrics to update.
//
// Returns:
//   - A pointer to the proto.UpdateMetricsResponse containing the updated metrics,
//     or an error if the operation fails.
func (m *MetricsServer) UpdateMetrics(ctx context.Context, in *proto.UpdateMetricsRequest) (*proto.UpdateMetricsResponse, error) <span class="cov8" title="1">{
        var response proto.UpdateMetricsResponse
        var metrics []metric.Metric

        for _, protoMetric := range in.Metrics </span><span class="cov8" title="1">{
                var me metric.Metric
                if protoMetric.Type == proto.Metric_GAUGE </span><span class="cov8" title="1">{
                        me = metric.Metric{
                                ID:    protoMetric.Id,
                                MType: router.MetricTypeGauge,
                                Value: &amp;protoMetric.Value,
                        }
                }</span> else<span class="cov8" title="1"> if protoMetric.Type == proto.Metric_COUNTER </span><span class="cov8" title="1">{
                        me = metric.Metric{
                                ID:    protoMetric.Id,
                                MType: router.MetricTypeCounter,
                                Delta: &amp;protoMetric.Delta,
                        }
                }</span> else<span class="cov0" title="0"> {
                        logger.Log.Info(`unknown metric type`)
                        return nil, status.Errorf(codes.InvalidArgument, `unknown metric type`)
                }</span>
                <span class="cov8" title="1">metrics = append(metrics, me)</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt;= m.RetryCount; i++ </span><span class="cov8" title="1">{
                err := m.Repository.UpdateMetrics(ctx, &amp;metrics)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != m.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">logger.Log.Info(`can't update metrics in database`, zap.Error(err))
                        return nil, status.Errorf(codes.Internal, `can't update metrics in database`)</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">for _, me := range metrics </span><span class="cov8" title="1">{
                if err := m.DumpMetric(&amp;me); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info(`error saving metrics`, zap.Error(err))
                        return nil, status.Errorf(codes.Internal, `error saving metrics`)
                }</span>
        }

        <span class="cov8" title="1">for _, met := range metrics </span><span class="cov8" title="1">{
                var (
                        updated *metric.Metric
                        err     error
                )
                for r := 0; r &lt;= m.RetryCount; r++ </span><span class="cov8" title="1">{
                        updated, err = m.Repository.GetMetric(ctx, met.MType, met.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                var pgErr *pgconn.PgError
                                if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                        if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; r != m.RetryCount </span><span class="cov8" title="1">{
                                                logger.Log.Info("repository connection error", zap.Error(err))
                                                time.Sleep(time.Duration(1+r*2) * time.Second)
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">logger.Log.Info("error get updated metric", zap.Error(err))
                                return nil, status.Errorf(codes.Internal, `error get updated metric`)</span>
                        }
                        <span class="cov8" title="1">prMetric := &amp;proto.Metric{
                                Id: updated.ID,
                        }
                        if updated.MType == router.MetricTypeGauge </span><span class="cov8" title="1">{
                                prMetric.Type = proto.Metric_GAUGE
                                prMetric.Value = *updated.Value
                        }</span> else<span class="cov8" title="1"> {
                                prMetric.Type = proto.Metric_COUNTER
                                prMetric.Delta = *updated.Delta
                        }</span>
                        <span class="cov8" title="1">response.Metrics = append(response.Metrics, prMetric)
                        break</span>
                }
        }

        <span class="cov8" title="1">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/Vidkin/metrics/internal/router (interfaces: Repository)

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"

        metric "github.com/Vidkin/metrics/internal/metric"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov8" title="1">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// DeleteMetric mocks base method.
func (m *MockRepository) DeleteMetric(arg0 context.Context, arg1, arg2 string) error <span class="cov0" title="0">{
        //m.ctrl.T.Helper()
        //ret := m.ctrl.Call(m, "DeleteMetric", arg0, arg1, arg2)
        //ret0, _ := ret[0].(error)
        //return ret0
        return nil
}</span>

// DeleteMetric indicates an expected call of DeleteMetric.
func (mr *MockRepositoryMockRecorder) DeleteMetric(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        //mr.mock.ctrl.T.Helper()
        //return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMetric", reflect.TypeOf((*MockRepository)(nil).DeleteMetric), arg0, arg1, arg2)
        return nil
}</span>

// GetCounters mocks base method.
func (m *MockRepository) GetCounters(arg0 context.Context) ([]*metric.Metric, error) <span class="cov0" title="0">{
        //m.ctrl.T.Helper()
        //ret := m.ctrl.Call(m, "GetCounters", arg0)
        //ret0, _ := ret[0].([]*metric.Metric)
        //ret1, _ := ret[1].(error)
        //return ret0, ret1
        return nil, nil
}</span>

// GetCounters indicates an expected call of GetCounters.
func (mr *MockRepositoryMockRecorder) GetCounters(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        //mr.mock.ctrl.T.Helper()
        //return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCounters", reflect.TypeOf((*MockRepository)(nil).GetCounters), arg0)
        return nil
}</span>

// GetGauges mocks base method.
func (m *MockRepository) GetGauges(arg0 context.Context) ([]*metric.Metric, error) <span class="cov0" title="0">{
        //m.ctrl.T.Helper()
        //ret := m.ctrl.Call(m, "GetGauges", arg0)
        //ret0, _ := ret[0].([]*metric.Metric)
        //ret1, _ := ret[1].(error)
        //return ret0, ret1
        return nil, nil
}</span>

// GetGauges indicates an expected call of GetGauges.
func (mr *MockRepositoryMockRecorder) GetGauges(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        //mr.mock.ctrl.T.Helper()
        //return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGauges", reflect.TypeOf((*MockRepository)(nil).GetGauges), arg0)
        return nil
}</span>

// GetMetric mocks base method.
func (m *MockRepository) GetMetric(arg0 context.Context, arg1, arg2 string) (*metric.Metric, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMetric", arg0, arg1, arg2)
        ret0, _ := ret[0].(*metric.Metric)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMetric indicates an expected call of GetMetric.
func (mr *MockRepositoryMockRecorder) GetMetric(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetric", reflect.TypeOf((*MockRepository)(nil).GetMetric), arg0, arg1, arg2)
}</span>

// GetMetrics mocks base method.
func (m *MockRepository) GetMetrics(arg0 context.Context) ([]*metric.Metric, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMetrics", arg0)
        ret0, _ := ret[0].([]*metric.Metric)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMetrics indicates an expected call of GetMetrics.
func (mr *MockRepositoryMockRecorder) GetMetrics(arg0 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetrics", reflect.TypeOf((*MockRepository)(nil).GetMetrics), arg0)
}</span>

// UpdateMetric mocks base method.
func (m *MockRepository) UpdateMetric(arg0 context.Context, arg1 *metric.Metric) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateMetric", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateMetric indicates an expected call of UpdateMetric.
func (mr *MockRepositoryMockRecorder) UpdateMetric(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMetric", reflect.TypeOf((*MockRepository)(nil).UpdateMetric), arg0, arg1)
}</span>

// UpdateMetrics mocks base method.
func (m *MockRepository) UpdateMetrics(arg0 context.Context, arg1 *[]metric.Metric) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateMetrics", arg0, arg1)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateMetrics indicates an expected call of UpdateMetrics.
func (mr *MockRepositoryMockRecorder) UpdateMetrics(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMetrics", reflect.TypeOf((*MockRepository)(nil).UpdateMetrics), arg0, arg1)
}</span>

// Dump mocks base method.
func (m *MockRepository) Dump(arg0 *metric.Metric) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Dump", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Dump indicates an expected call of Dump.
func (mr *MockRepositoryMockRecorder) Dump(arg0 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dump", reflect.TypeOf((*MockRepository)(nil).Dump), arg0)
}</span>

// FullDump mocks base method.
func (m *MockRepository) FullDump() error <span class="cov0" title="0">{
        //m.ctrl.T.Helper()
        //ret := m.ctrl.Call(m, "FullDump")
        //ret0, _ := ret[0].(error)
        //return ret0
        return nil
}</span>

// FullDump indicates an expected call of FullDump.
func (mr *MockRepositoryMockRecorder) FullDump() *gomock.Call <span class="cov0" title="0">{
        //mr.mock.ctrl.T.Helper()
        //return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FullDump", reflect.TypeOf((*MockRepository)(nil).FullDump))
        return nil
}</span>

// Ping mocks base method.
func (m *MockRepository) Ping(arg0 context.Context) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Ping", arg0)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Ping indicates an expected call of Ping.
func (mr *MockRepositoryMockRecorder) Ping(arg0 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockRepository)(nil).Ping), arg0)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "errors"
        "io"
        "os"
        "sync"

        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/logger"
        me "github.com/Vidkin/metrics/internal/metric"
)

type FileStorage struct {
        Gauge           map[string]float64
        Counter         map[string]int64
        FileStoragePath string
        GaugeMetrics    []*me.Metric
        CounterMetrics  []*me.Metric
        AllMetrics      []*me.Metric
        mu              sync.RWMutex
}

func (f *FileStorage) UpdateMetric(_ context.Context, metric *me.Metric) error <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()

        switch metric.MType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                f.Gauge[metric.ID] = *metric.Value</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                f.Counter[metric.ID] += *metric.Delta</span>
        default:<span class="cov8" title="1">
                return errors.New("unknown metric type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (f *FileStorage) UpdateMetrics(_ context.Context, metrics *[]me.Metric) error <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()

        for _, metric := range *metrics </span><span class="cov8" title="1">{
                switch metric.MType </span>{
                case MetricTypeGauge:<span class="cov8" title="1">
                        f.Gauge[metric.ID] = *metric.Value</span>
                case MetricTypeCounter:<span class="cov8" title="1">
                        f.Counter[metric.ID] += *metric.Delta</span>
                default:<span class="cov8" title="1">
                        return errors.New("unknown metric type")</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (f *FileStorage) DeleteMetric(_ context.Context, mType string, name string) error <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()

        switch mType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                delete(f.Gauge, name)</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                delete(f.Counter, name)</span>
        default:<span class="cov8" title="1">
                return errors.New("unknown metric type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (f *FileStorage) GetMetric(_ context.Context, mType string, name string) (*me.Metric, error) <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        var metric me.Metric
        switch mType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                v, ok := f.Gauge[name]
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("metric not found")
                }</span>
                <span class="cov8" title="1">metric.ID = name
                metric.MType = MetricTypeGauge
                metric.Value = &amp;v</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                v, ok := f.Counter[name]
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("metric not found")
                }</span>
                <span class="cov8" title="1">metric.ID = name
                metric.MType = MetricTypeCounter
                metric.Delta = &amp;v</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("unknown metric type")</span>
        }
        <span class="cov8" title="1">return &amp;metric, nil</span>
}

func (f *FileStorage) GetMetrics(ctx context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        f.AllMetrics = f.AllMetrics[:0]
        if _, err := f.GetGauges(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if _, err := f.GetCounters(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">f.AllMetrics = append(f.AllMetrics, f.GaugeMetrics...)
        f.AllMetrics = append(f.AllMetrics, f.CounterMetrics...)
        return f.AllMetrics, nil</span>
}

func (f *FileStorage) GetGauges(_ context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        f.GaugeMetrics = f.GaugeMetrics[:0]
        for k, v := range f.Gauge </span><span class="cov8" title="1">{
                f.GaugeMetrics = append(f.GaugeMetrics, &amp;me.Metric{
                        ID:    k,
                        Value: &amp;v,
                        MType: MetricTypeGauge,
                })
        }</span>
        <span class="cov8" title="1">return f.GaugeMetrics, nil</span>
}

func (f *FileStorage) GetCounters(_ context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        f.CounterMetrics = f.CounterMetrics[:0]
        for k, v := range f.Counter </span><span class="cov8" title="1">{
                f.CounterMetrics = append(f.CounterMetrics, &amp;me.Metric{
                        ID:    k,
                        Delta: &amp;v,
                        MType: MetricTypeCounter,
                })
        }</span>
        <span class="cov8" title="1">return f.CounterMetrics, nil</span>
}

func (f *FileStorage) Dump(metric *me.Metric) error <span class="cov8" title="1">{
        file, err := os.OpenFile(f.FileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov8" title="1">{
                logger.Log.Info("error open file", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error read file", zap.Error(err))
                return err
        }</span>

        <span class="cov8" title="1">var metrics []me.Metric
        if len(data) != 0 </span><span class="cov8" title="1">{
                if err = json.Unmarshal(data, &amp;metrics); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">found := false
        for index, met := range metrics </span><span class="cov8" title="1">{
                if met.ID == metric.ID &amp;&amp; met.MType == metric.MType </span><span class="cov8" title="1">{
                        if met.MType == MetricTypeCounter </span><span class="cov8" title="1">{
                                metrics[index].Delta = metric.Delta
                        }</span>
                        <span class="cov8" title="1">if met.MType == MetricTypeGauge </span><span class="cov8" title="1">{
                                metrics[index].Value = metric.Value
                        }</span>
                        <span class="cov8" title="1">found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                metrics = append(metrics, *metric)
        }</span>

        <span class="cov8" title="1">b, err := json.Marshal(metrics)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal metrics", zap.Error(err))
                return err
        }</span>

        <span class="cov8" title="1">err = os.WriteFile(f.FileStoragePath, b, 0666)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error write file", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (f *FileStorage) FullDump() error <span class="cov8" title="1">{
        file, err := os.OpenFile(f.FileStoragePath, os.O_WRONLY|os.O_APPEND|os.O_CREATE|os.O_TRUNC, 0666)
        if err != nil </span><span class="cov8" title="1">{
                logger.Log.Info("error open file", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        gauge, err := f.GetGauges(context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get gauges", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">counter, err := f.GetCounters(context.TODO())
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get counters", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">metrics := append(gauge, counter...)

        b, err := json.Marshal(metrics)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal metrics", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">_, err = file.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error write file", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (f *FileStorage) Load(ctx context.Context) error <span class="cov8" title="1">{
        file, err := os.OpenFile(f.FileStoragePath, os.O_RDONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov8" title="1">{
                logger.Log.Info("error open file", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error read file", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">var metrics []me.Metric
        if err := json.Unmarshal(data, &amp;metrics); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, metric := range metrics </span><span class="cov0" title="0">{
                if err := f.UpdateMetric(ctx, &amp;metric); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package storage

import (
        "context"
        "errors"
        "sync"

        me "github.com/Vidkin/metrics/internal/metric"
)

const (
        MetricTypeCounter = "counter"
        MetricTypeGauge   = "gauge"
)

type MemoryStorage struct {
        Gauge          map[string]float64
        Counter        map[string]int64
        GaugeMetrics   []*me.Metric
        CounterMetrics []*me.Metric
        AllMetrics     []*me.Metric
        mu             sync.RWMutex
}

func (m *MemoryStorage) UpdateMetric(_ context.Context, metric *me.Metric) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        switch metric.MType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                m.Gauge[metric.ID] = *metric.Value</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                m.Counter[metric.ID] += *metric.Delta</span>
        default:<span class="cov8" title="1">
                return errors.New("unknown metric type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MemoryStorage) UpdateMetrics(_ context.Context, metrics *[]me.Metric) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for _, metric := range *metrics </span><span class="cov8" title="1">{
                switch metric.MType </span>{
                case MetricTypeGauge:<span class="cov8" title="1">
                        m.Gauge[metric.ID] = *metric.Value</span>
                case MetricTypeCounter:<span class="cov8" title="1">
                        m.Counter[metric.ID] += *metric.Delta</span>
                default:<span class="cov8" title="1">
                        return errors.New("unknown metric type")</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MemoryStorage) DeleteMetric(_ context.Context, mType string, name string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        switch mType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                delete(m.Gauge, name)</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                delete(m.Counter, name)</span>
        default:<span class="cov8" title="1">
                return errors.New("unknown metric type")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *MemoryStorage) GetMetric(_ context.Context, mType string, name string) (*me.Metric, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        var metric me.Metric
        switch mType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                v, ok := m.Gauge[name]
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("metric not found")
                }</span>
                <span class="cov8" title="1">metric.ID = name
                metric.MType = MetricTypeGauge
                metric.Value = &amp;v</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                v, ok := m.Counter[name]
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("metric not found")
                }</span>
                <span class="cov8" title="1">metric.ID = name
                metric.MType = MetricTypeCounter
                metric.Delta = &amp;v</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("unknown metric type")</span>
        }
        <span class="cov8" title="1">return &amp;metric, nil</span>
}

func (m *MemoryStorage) GetMetrics(ctx context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        m.AllMetrics = m.AllMetrics[:0]
        if _, err := m.GetGauges(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if _, err := m.GetCounters(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m.AllMetrics = append(m.AllMetrics, m.GaugeMetrics...)
        m.AllMetrics = append(m.AllMetrics, m.CounterMetrics...)
        return m.AllMetrics, nil</span>
}

func (m *MemoryStorage) GetGauges(_ context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        m.GaugeMetrics = m.GaugeMetrics[:0]
        for k, v := range m.Gauge </span><span class="cov8" title="1">{
                m.GaugeMetrics = append(m.GaugeMetrics, &amp;me.Metric{
                        ID:    k,
                        Value: &amp;v,
                        MType: MetricTypeGauge,
                })
        }</span>
        <span class="cov8" title="1">return m.GaugeMetrics, nil</span>
}

func (m *MemoryStorage) GetCounters(_ context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        m.CounterMetrics = m.CounterMetrics[:0]
        for k, v := range m.Counter </span><span class="cov8" title="1">{
                m.CounterMetrics = append(m.CounterMetrics, &amp;me.Metric{
                        ID:    k,
                        Delta: &amp;v,
                        MType: MetricTypeCounter,
                })
        }</span>
        <span class="cov8" title="1">return m.CounterMetrics, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package storage

import (
        "context"
        "database/sql"
        "embed"
        "errors"

        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/jackc/pgx/v5/stdlib"
        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/logger"
        me "github.com/Vidkin/metrics/internal/metric"
)

//go:embed migrations/*.sql
var Migrations embed.FS

type PostgresStorage struct {
        Conn           *sql.DB
        GaugeMetrics   []*me.Metric
        CounterMetrics []*me.Metric
        AllMetrics     []*me.Metric
}

func (p *PostgresStorage) UpdateMetric(ctx context.Context, metric *me.Metric) error <span class="cov8" title="1">{
        switch metric.MType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                _, err := p.GetMetric(ctx, metric.MType, metric.ID)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        _, err = p.Conn.ExecContext(ctx, "INSERT INTO gauge (metric_name, metric_value) VALUES ($1, $2)", metric.ID, *metric.Value)
                        return err
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error get gauge metric", zap.Error(err))
                        return err
                }</span>
                <span class="cov8" title="1">_, err = p.Conn.ExecContext(ctx, "UPDATE gauge SET metric_value=$1 WHERE metric_name=$2", *metric.Value, metric.ID)
                return err</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                _, err := p.GetMetric(ctx, metric.MType, metric.ID)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        _, err = p.Conn.ExecContext(ctx, "INSERT INTO counter (metric_name, metric_value) VALUES ($1, $2)", metric.ID, *metric.Delta)
                        return err
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error get counter metric", zap.Error(err))
                        return err
                }</span>
                <span class="cov8" title="1">_, err = p.Conn.ExecContext(ctx, "UPDATE counter SET metric_value=metric_value+$1 WHERE metric_name=$2", *metric.Delta, metric.ID)
                return err</span>
        default:<span class="cov8" title="1">
                return errors.New("unknown metric type")</span>
        }
}

func (p *PostgresStorage) UpdateMetrics(ctx context.Context, metrics *[]me.Metric) error <span class="cov8" title="1">{
        tx, err := p.Conn.Begin()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error begin tx", zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()
        for _, metric := range *metrics </span><span class="cov8" title="1">{
                switch metric.MType </span>{
                case MetricTypeGauge:<span class="cov8" title="1">
                        row := tx.QueryRowContext(ctx, "SELECT metric_id from gauge WHERE metric_name=$1", metric.ID)
                        var metricID int64
                        err = row.Scan(&amp;metricID)
                        if err != nil </span><span class="cov8" title="1">{
                                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                                        _, err = tx.ExecContext(ctx, "INSERT INTO gauge (metric_name, metric_value) VALUES ($1, $2)", metric.ID, *metric.Value)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Info("error insert gauge metric", zap.Error(err))
                                                return err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logger.Log.Info("error scan gauge metric", zap.Error(err))
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">_, err = tx.ExecContext(ctx, "UPDATE gauge SET metric_value=$1 WHERE metric_id=$2", *metric.Value, metricID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Info("error update gauge metric", zap.Error(err))
                                return err
                        }</span>
                case MetricTypeCounter:<span class="cov8" title="1">
                        row := tx.QueryRowContext(ctx, "SELECT metric_id from counter WHERE metric_name=$1", metric.ID)
                        var metricID int64
                        err = row.Scan(&amp;metricID)
                        if err != nil </span><span class="cov8" title="1">{
                                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                                        _, err = tx.ExecContext(ctx, "INSERT INTO counter (metric_name, metric_value) VALUES ($1, $2)", metric.ID, *metric.Delta)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Info("error insert counter metric", zap.Error(err))
                                                return err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logger.Log.Info("error scan counter metric", zap.Error(err))
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">_, err = tx.ExecContext(ctx, "UPDATE counter SET metric_value=metric_value+$1 WHERE metric_id=$2", *metric.Delta, metricID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Info("error update counter metric", zap.Error(err))
                                return err
                        }</span>
                default:<span class="cov8" title="1">
                        logger.Log.Info("unknown metric type")
                        return errors.New("unknown metric type")</span>
                }
        }
        <span class="cov8" title="1">return tx.Commit()</span>
}

func (p *PostgresStorage) DeleteMetric(ctx context.Context, mType string, name string) error <span class="cov8" title="1">{
        switch mType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                stmt, err := p.Conn.PrepareContext(ctx, "DELETE from gauge WHERE metric_name=$1")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error prepare stmt", zap.Error(err))
                        return err
                }</span>
                <span class="cov8" title="1">defer stmt.Close()
                _, err = stmt.ExecContext(ctx, name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error delete gauge metric", zap.Error(err))
                }</span>
                <span class="cov8" title="1">return err</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                stmt, err := p.Conn.PrepareContext(ctx, "DELETE from counter WHERE metric_name=$1")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error prepare stmt", zap.Error(err))
                        return err
                }</span>
                <span class="cov8" title="1">defer stmt.Close()
                _, err = stmt.ExecContext(ctx, name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error delete counter metric", zap.Error(err))
                }</span>
                <span class="cov8" title="1">return err</span>
        default:<span class="cov8" title="1">
                logger.Log.Info("unknown metric type")
                return errors.New("unknown metric type")</span>
        }
}

func (p *PostgresStorage) GetMetric(ctx context.Context, mType string, name string) (*me.Metric, error) <span class="cov8" title="1">{
        switch mType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                stmt, err := p.Conn.PrepareContext(ctx, "SELECT metric_name, metric_value from gauge WHERE metric_name=$1")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error prepare stmt", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer stmt.Close()
                row := stmt.QueryRowContext(ctx, name)
                var m me.Metric
                err = row.Scan(&amp;m.ID, &amp;m.Value)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Log.Info("error scan gauge metric", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov8" title="1">m.MType = MetricTypeGauge
                return &amp;m, nil</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                stmt, err := p.Conn.PrepareContext(ctx, "SELECT metric_name, metric_value from counter WHERE metric_name=$1")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error prepare stmt", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer stmt.Close()
                row := stmt.QueryRowContext(ctx, name)
                var m me.Metric
                err = row.Scan(&amp;m.ID, &amp;m.Delta)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Log.Info("error scan counter metric", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov8" title="1">m.MType = MetricTypeCounter
                return &amp;m, nil</span>
        default:<span class="cov8" title="1">
                logger.Log.Info("unknown metric type")
                return nil, errors.New("unknown metric type")</span>
        }
}

func (p *PostgresStorage) GetMetrics(ctx context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        p.AllMetrics = p.AllMetrics[:0]
        if _, err := p.GetGauges(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get gauges", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">if _, err := p.GetCounters(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get counters", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">p.AllMetrics = append(p.AllMetrics, p.GaugeMetrics...)
        p.AllMetrics = append(p.AllMetrics, p.CounterMetrics...)
        return p.AllMetrics, nil</span>
}

func (p *PostgresStorage) GetGauges(ctx context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        p.GaugeMetrics = p.GaugeMetrics[:0]
        stmt, err := p.Conn.PrepareContext(ctx, "SELECT metric_name, metric_value from gauge")
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error prepare stmt", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">defer stmt.Close()
        rows, err := stmt.QueryContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get gauges", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var m me.Metric
                if err = rows.Scan(&amp;m.ID, &amp;m.Value); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error scan gauge metric", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov8" title="1">m.MType = MetricTypeGauge
                p.GaugeMetrics = append(p.GaugeMetrics, &amp;m)</span>
        }
        <span class="cov8" title="1">if rows.Err() != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error rows", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">return p.GaugeMetrics, nil</span>
}

func (p *PostgresStorage) GetCounters(ctx context.Context) ([]*me.Metric, error) <span class="cov8" title="1">{
        p.CounterMetrics = p.CounterMetrics[:0]
        stmt, err := p.Conn.PrepareContext(ctx, "SELECT metric_name, metric_value from counter")
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error prepare stmt", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">defer stmt.Close()
        rows, err := stmt.QueryContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error get counters", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                var m me.Metric
                if err = rows.Scan(&amp;m.ID, &amp;m.Delta); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("error scan counter metric", zap.Error(err))
                        return nil, err
                }</span>
                <span class="cov8" title="1">m.MType = MetricTypeCounter
                p.CounterMetrics = append(p.CounterMetrics, &amp;m)</span>
        }
        <span class="cov8" title="1">if rows.Err() != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error rows", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">return p.CounterMetrics, nil</span>
}

func (p *PostgresStorage) Ping(ctx context.Context) error <span class="cov8" title="1">{
        return p.Conn.PingContext(ctx)
}</span>

func (p *PostgresStorage) Close() error <span class="cov8" title="1">{
        return p.Conn.Close()
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package router provides an HTTP routing implementation for handling metrics-related operations.
package router

import (
        "context"
        "database/sql/driver"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "strconv"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5/pgconn"
        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/internal/metric"
        "github.com/Vidkin/metrics/pkg/middleware"
)

// Constants for metric parameters and types.
//
// These constants are used in the context of metrics handling within the
// MetricRouter. They define the names of URL parameters and the types of
// metrics that can be processed.
//
// Parameters:
//   - ParamMetricType: The name of the URL parameter that specifies the type
//     of the metric (e.g., "counter" or "gauge").
//   - ParamMetricName: The name of the URL parameter that specifies the name
//     of the metric.
//   - ParamMetricValue: The name of the URL parameter that specifies the value
//     of the metric.
//
// Metric Types:
//   - MetricTypeCounter: A constant representing the "counter" metric type.
//   - MetricTypeGauge: A constant representing the "gauge" metric type.
const (
        ParamMetricType  = "metricType"
        ParamMetricName  = "metricName"
        ParamMetricValue = "metricValue"

        MetricTypeCounter = "counter"
        MetricTypeGauge   = "gauge"
)

// MetricRouter is a struct that manages HTTP routing for metrics-related
// operations. It holds a reference to a Repository for data storage and
// retrieval, as well as a chi.Router for handling HTTP requests. The
// MetricRouter also maintains configuration settings such as the number
// of retry attempts for database operations, the last time metrics were
// stored, and the interval for storing metrics.
//
// Fields:
//   - Repository: An instance of the Repository interface that provides
//     methods for updating, retrieving, and deleting metrics from a data
//     store.
//   - Router: A chi.Router instance that defines the routing for HTTP
//     requests related to metrics.
//   - RetryCount: The number of times to retry database operations in case
//     of transient errors.
//   - LastStoreTime: A time.Time value that indicates the last time metrics
//     were successfully stored in the repository.
//   - StoreInterval: An integer that specifies the interval for storing
//     metrics, which can be used to control when metrics should be dumped
//     to the repository.
type MetricRouter struct {
        Repository    Repository
        Router        chi.Router
        LastStoreTime time.Time
        RetryCount    int
        StoreInterval int
}

// Repository defines the methods required for a metrics data store.
// It provides an abstraction for updating, deleting, and retrieving
// metrics from a persistent storage solution. Implementations of this
// interface should handle the underlying data storage logic, allowing
// the MetricRouter to interact with various data sources without
// being tightly coupled to a specific implementation.
type Repository interface {
        UpdateMetric(ctx context.Context, metric *metric.Metric) error
        UpdateMetrics(ctx context.Context, metrics *[]metric.Metric) error
        DeleteMetric(ctx context.Context, mType string, name string) error

        GetMetric(ctx context.Context, mType string, name string) (*metric.Metric, error)
        GetMetrics(ctx context.Context) ([]*metric.Metric, error)
        GetGauges(ctx context.Context) ([]*metric.Metric, error)
        GetCounters(ctx context.Context) ([]*metric.Metric, error)
}

// Dumper defines the methods required for dump metrics
// to a storage system or output format. Implementations of this interface
// should provide functionality to save individual metrics as well as to
// perform a complete dump of all metrics.
type Dumper interface {
        Dump(metric *metric.Metric) error
        FullDump() error
}

// Ping checks the availability of the provided Repository by attempting to
// ping it. If the Repository implements the driver.Pinger interface, it
// calls the Ping method on it, passing the provided context. If the
// Repository does not implement the Pinger interface, it returns an error
// indicating that the provided Repository does not support pinging.
//
// Parameters:
//   - r: A Repository instance that is expected to implement the Pinger
//     interface.
//   - ctx: A context.Context to control the lifetime of the ping operation.
//
// Returns:
//   - An error if the ping operation fails or if the Repository does not
//     implement the Pinger interface; otherwise, it returns nil.
func Ping(r Repository, ctx context.Context) error <span class="cov8" title="1">{
        if pinger, ok := r.(driver.Pinger); ok </span><span class="cov8" title="1">{
                return pinger.Ping(ctx)
        }</span>
        <span class="cov0" title="0">return errors.New("provided Repository does not implement Pinger")</span>
}

// DumpMetric attempts to dump a given metric to the provided Repository.
// It checks if the Repository implements the Dumper interface. If it does,
// the function calls the Dump method of the Dumper interface to persist
// the metric. If the Repository does not implement the Dumper interface,
// the function returns an error indicating that the provided Repository
// cannot perform the dump operation.
//
// Parameters:
//   - r: A Repository instance that is expected to implement the Dumper
//     interface.
//   - m: A pointer to the metric.Metric that needs to be dumped.
//
// Returns:
//   - An error if the dumping operation fails or if the Repository does
//     not implement the Dumper interface; otherwise, it returns nil.
func DumpMetric(r Repository, m *metric.Metric) error <span class="cov8" title="1">{
        if dumper, ok := r.(Dumper); ok </span><span class="cov8" title="1">{
                return dumper.Dump(m)
        }</span>
        <span class="cov0" title="0">return errors.New("provided Repository does not implement Dumper")</span>
}

// Close attempts to close the provided Repository if it implements the
// io.Closer interface. If the Repository does implement the Closer
// interface, the function calls its Close method to release any resources
// or connections. If the Repository does not implement the Closer
// interface, the function returns an error indicating that the provided
// Repository cannot be closed.
//
// Parameters:
//   - r: A Repository instance that is expected to implement the io.Closer
//     interface.
//
// Returns:
//   - An error if the closing operation fails or if the Repository does
//     not implement the Closer interface; otherwise, it returns nil.
func Close(r Repository) error <span class="cov0" title="0">{
        if closer, ok := r.(io.Closer); ok </span><span class="cov0" title="0">{
                return closer.Close()
        }</span>
        <span class="cov0" title="0">return errors.New("provided Repository does not implement Closer")</span>
}

// NewMetricRouter initializes a new MetricRouter with the provided chi.Mux,
// Repository, and server configuration. It sets up the necessary middleware
// for logging, hashing (if a key is provided), and gzip compression. The
// function also defines the routing for various HTTP endpoints related to
// metrics, including handlers for retrieving, updating, and checking the
// status of metrics.
//
// Parameters:
//   - router: A pointer to a chi.Mux instance that will handle the HTTP
//     routing for the metrics API.
//   - repository: An instance of the Repository interface that will be
//     used for storing and retrieving metrics data.
//   - serverConfig: A pointer to a config.ServerConfig struct that contains
//     configuration settings such as the store interval and retry count.
//
// Returns:
//   - A pointer to a newly created MetricRouter instance, which is ready
//     to handle HTTP requests related to metrics.
func NewMetricRouter(router *chi.Mux, repository Repository, serverConfig *config.ServerConfig) *MetricRouter <span class="cov8" title="1">{
        var mr MetricRouter
        router.Use(middleware.Logging)
        if serverConfig.TrustedSubnet != "" </span><span class="cov8" title="1">{
                router.Use(middleware.TrustedSubnet(serverConfig.TrustedSubnet))
        }</span>
        <span class="cov8" title="1">if serverConfig.Key != "" </span><span class="cov8" title="1">{
                router.Use(middleware.Hash(serverConfig.Key))
        }</span>
        <span class="cov8" title="1">router.Use(middleware.Gzip)

        router.Route("/", func(r chi.Router) </span><span class="cov8" title="1">{
                r.Get("/", mr.RootHandler)
                r.Route("/ping", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Get("/", mr.PingDBHandler)
                }</span>)
                <span class="cov8" title="1">r.Route("/value", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/", mr.GetMetricValueHandlerJSON)
                        r.Get("/{metricType}/{metricName}", mr.GetMetricValueHandler)
                }</span>)
                <span class="cov8" title="1">r.Route("/update", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/", mr.UpdateMetricHandlerJSON)
                        r.Post("/{metricType}/{metricName}/{metricValue}", mr.UpdateMetricHandler)
                }</span>)
                <span class="cov8" title="1">r.Route("/updates", func(r chi.Router) </span><span class="cov8" title="1">{
                        r.Post("/", mr.UpdateMetricsHandlerJSON)
                }</span>)
        })
        <span class="cov8" title="1">mr.Router = router
        mr.Repository = repository
        mr.StoreInterval = (int)(serverConfig.StoreInterval)
        mr.RetryCount = serverConfig.RetryCount
        mr.LastStoreTime = time.Now()
        return &amp;mr</span>
}

// RootHandler handles HTTP GET requests to the root endpoint ("/") of the
// metrics API. It retrieves all metrics from the repository and writes
// them to the HTTP response in a plain text format. The response content
// type is set to "text/html".
//
// Parameters:
//   - res: An http.ResponseWriter used to construct the HTTP response.
//   - req: An http.Request containing the details of the incoming request.
func (mr *MetricRouter) RootHandler(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        res.Header().Set("Content-Type", "text/html")

        var (
                metrics []*metric.Metric
                err     error
        )

        for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                metrics, err = mr.Repository.GetMetrics(req.Context())
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("error get metrics", zap.Error(err))
                        http.Error(res, "error get metrics", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">for _, me := range metrics </span><span class="cov8" title="1">{
                if me.MType == MetricTypeGauge </span><span class="cov8" title="1">{
                        _, _ = io.WriteString(res, fmt.Sprintf("%s = %v\n", me.ID, *me.Value))
                }</span>
                <span class="cov8" title="1">if me.MType == MetricTypeCounter </span><span class="cov8" title="1">{
                        _, _ = io.WriteString(res, fmt.Sprintf("%s = %d\n", me.ID, *me.Delta))
                }</span>
        }

        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

// PingDBHandler handles HTTP GET requests to the "/ping" endpoint of the
// metrics API. It checks the availability of the database by attempting to
// ping the repository associated with the MetricRouter.
//
// Parameters:
//   - res: An http.ResponseWriter used to construct the HTTP response.
//   - req: An http.Request containing the details of the incoming request.
func (mr *MetricRouter) PingDBHandler(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        res.Header().Set("Content-Type", "text/plain")
        if err := Ping(mr.Repository, req.Context()); err != nil </span><span class="cov8" title="1">{
                logger.Log.Info("couldn't connect to database")
                res.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

// GetMetricValueHandler handles HTTP GET requests to retrieve the value of
// a specific metric identified by its type and name. The metric type must
// be either "gauge" or "counter".
//
// Parameters:
//   - res: An http.ResponseWriter used to construct the HTTP response.
//   - req: An http.Request containing the details of the incoming request.
func (mr *MetricRouter) GetMetricValueHandler(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        metricType := chi.URLParam(req, ParamMetricType)
        metricName := chi.URLParam(req, ParamMetricName)

        if metricType != MetricTypeGauge &amp;&amp; metricType != MetricTypeCounter </span><span class="cov8" title="1">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var (
                me  *metric.Metric
                err error
        )

        for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                me, err = mr.Repository.GetMetric(req.Context(), metricType, metricName)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("metric not found", zap.Error(err))
                        http.Error(res, "metric not found", http.StatusNotFound)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">res.Header().Set("Content-Type", "text/plain; charset=utf-8")
        _, err = res.Write([]byte(me.ValueAsString()))
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("can't write metric value", zap.Error(err))
                http.Error(res, "Can't write metric value", http.StatusInternalServerError)
        }</span>
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

// DumpMetric attempts to persist a given metric to the repository if the
// StoreInterval is set to zero. The method retries the dumping operation
// up to the configured RetryCount in case of transient errors, such as
// connection issues.
//
// Parameters:
//   - metric: A pointer to the metric.Metric that needs to be dumped.
//
// Returns:
//   - An error if the dumping operation fails; otherwise, it returns nil.
func (mr *MetricRouter) DumpMetric(metric *metric.Metric) error <span class="cov8" title="1">{
        if mr.StoreInterval == 0 </span><span class="cov8" title="1">{
                for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                        err := DumpMetric(mr.Repository, metric)
                        if err != nil </span><span class="cov8" title="1">{
                                var pathErr *os.PathError
                                if errors.As(err, &amp;pathErr) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                                <span class="cov8" title="1">logger.Log.Info("error saving metric", zap.Error(err))
                                return errors.New("error saving metric")</span>
                        }
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// UpdateMetricHandler handles HTTP POST requests to update the value of
// a specific metric identified by its type and name. The metric type must
// be either "gauge" or "counter".
//
// Parameters:
//   - res: An http.ResponseWriter used to construct the HTTP response.
//   - req: An http.Request containing the details of the incoming request.
func (mr *MetricRouter) UpdateMetricHandler(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        metricType := chi.URLParam(req, ParamMetricType)
        metricName := chi.URLParam(req, ParamMetricName)
        metricValue := chi.URLParam(req, ParamMetricValue)

        if metricName == "" </span><span class="cov0" title="0">{
                http.Error(res, "Empty metric name!", http.StatusNotFound)
        }</span>

        <span class="cov8" title="1">if metricType != MetricTypeGauge &amp;&amp; metricType != MetricTypeCounter </span><span class="cov8" title="1">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">me := metric.Metric{
                ID:    metricName,
                MType: metricType,
        }

        var (
                floatValue float64
                intValue   int64
                err        error
        )

        if metricType == MetricTypeGauge </span><span class="cov8" title="1">{
                floatValue, err = strconv.ParseFloat(metricValue, 64)
                me.Value = &amp;floatValue
        }</span>

        <span class="cov8" title="1">if metricType == MetricTypeCounter </span><span class="cov8" title="1">{
                intValue, err = strconv.ParseInt(metricValue, 10, 64)
                me.Delta = &amp;intValue
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                logger.Log.Info("can't convert metric value", zap.Error(err))
                http.Error(res, "Bad metric value!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                err := mr.Repository.UpdateMetric(req.Context(), &amp;me)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("bad metric value", zap.Error(err))
                        http.Error(res, "bad metric value", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if err := mr.DumpMetric(&amp;me); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "error saving metric", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.Header().Set("Content-Type", "text/plain; charset=utf-8")
        res.WriteHeader(http.StatusOK)</span>
}

// UpdateMetricHandlerJSON handles HTTP POST requests for updating a metric in JSON format.
//
// Parameters:
// - res: An http.ResponseWriter used to construct the HTTP response.
// - req: An http.Request containing the HTTP request data, including the JSON body.
func (mr *MetricRouter) UpdateMetricHandlerJSON(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                http.Error(res, "only application/json content-type allowed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var me metric.Metric
        if err := json.NewDecoder(req.Body).Decode(&amp;me); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "can't decode request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">switch me.MType </span>{
        case MetricTypeGauge:<span class="cov8" title="1">
                if me.Value == nil </span><span class="cov8" title="1">{
                        http.Error(res, "empty metric value", http.StatusBadRequest)
                        return
                }</span>
        case MetricTypeCounter:<span class="cov8" title="1">
                if me.Delta == nil </span><span class="cov8" title="1">{
                        http.Error(res, "empty metric delta", http.StatusBadRequest)
                        return
                }</span>
        default:<span class="cov8" title="1">
                http.Error(res, "bad metric type", http.StatusBadRequest)
                return</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                err := mr.Repository.UpdateMetric(req.Context(), &amp;me)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("error update metric", zap.Error(err))
                        http.Error(res, "error update metric", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if err := mr.DumpMetric(&amp;me); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "error saving metric", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">var (
                actualMetric *metric.Metric
                err          error
        )
        for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                actualMetric, err = mr.Repository.GetMetric(req.Context(), me.MType, me.ID)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("error get actual metric value", zap.Error(err))
                        http.Error(res, "error get actual metric value", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">res.Header().Set("Content-Type", "application/json")
        data, err := json.Marshal(actualMetric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal json response", zap.Error(err))
                http.Error(res, "error marshal json response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">_, err = res.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error write response data", zap.Error(err))
                http.Error(res, "error write response data", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

// GetMetricValueHandlerJSON handles HTTP POST requests for retrieving a metric value in JSON format.
//
// Parameters:
// - res: An http.ResponseWriter used to construct the HTTP response.
// - req: An http.Request containing the HTTP request data, including the JSON body.
func (mr *MetricRouter) GetMetricValueHandlerJSON(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                http.Error(res, "only application/json content-type allowed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var me metric.Metric
        if err := json.NewDecoder(req.Body).Decode(&amp;me); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "can't decode request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if me.MType != MetricTypeGauge &amp;&amp; me.MType != MetricTypeCounter </span><span class="cov8" title="1">{
                http.Error(res, "Bad metric type!", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var (
                respMetric *metric.Metric
                err        error
        )
        for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                respMetric, err = mr.Repository.GetMetric(req.Context(), me.MType, me.ID)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("metric not found", zap.Error(err))
                        http.Error(res, "metric not found", http.StatusNotFound)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">res.Header().Set("Content-Type", "application/json")

        data, err := json.Marshal(respMetric)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error marshal json response", zap.Error(err))
                http.Error(res, "error marshal json response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">_, err = res.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error write response data", zap.Error(err))
                http.Error(res, "error write response data", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}

// UpdateMetricsHandlerJSON handles HTTP POST requests for updating multiple metrics in JSON format.
//
// Parameters:
// - res: An http.ResponseWriter used to construct the HTTP response.
// - req: An http.Request containing the HTTP request data, including the JSON body.
func (mr *MetricRouter) UpdateMetricsHandlerJSON(res http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                http.Error(res, "only application/json content-type allowed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">var metrics []metric.Metric
        if err := json.NewDecoder(req.Body).Decode(&amp;metrics); err != nil </span><span class="cov8" title="1">{
                http.Error(res, "can't decode request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">defer func(body io.ReadCloser) </span><span class="cov8" title="1">{
                err := body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Info("can't close request body", zap.Error(err))
                }</span>
        }(req.Body)

        <span class="cov8" title="1">for _, m := range metrics </span><span class="cov8" title="1">{
                if (m.Value == nil &amp;&amp; m.Delta == nil) || (m.MType != MetricTypeCounter &amp;&amp; m.MType != MetricTypeGauge) </span><span class="cov8" title="1">{
                        http.Error(res, "bad metric", http.StatusBadRequest)
                        return
                }</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt;= mr.RetryCount; i++ </span><span class="cov8" title="1">{
                err := mr.Repository.UpdateMetrics(req.Context(), &amp;metrics)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; i != mr.RetryCount </span><span class="cov8" title="1">{
                                        logger.Log.Info("repository connection error", zap.Error(err))
                                        time.Sleep(time.Duration(1+i*2) * time.Second)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">logger.Log.Info("error update metrics", zap.Error(err))
                        http.Error(res, "error update metrics", http.StatusInternalServerError)
                        return</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">for _, me := range metrics </span><span class="cov8" title="1">{
                if err := mr.DumpMetric(&amp;me); err != nil </span><span class="cov8" title="1">{
                        http.Error(res, "error saving metric", http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov8" title="1">for i, m := range metrics </span><span class="cov8" title="1">{
                var (
                        updated *metric.Metric
                        err     error
                )
                for r := 0; r &lt;= mr.RetryCount; r++ </span><span class="cov8" title="1">{
                        updated, err = mr.Repository.GetMetric(req.Context(), m.MType, m.ID)
                        if err != nil </span><span class="cov8" title="1">{
                                var pgErr *pgconn.PgError
                                if errors.As(err, &amp;pgErr) </span><span class="cov8" title="1">{
                                        if pgerrcode.IsConnectionException(pgErr.Code) &amp;&amp; r != mr.RetryCount </span><span class="cov8" title="1">{
                                                logger.Log.Info("repository connection error", zap.Error(err))
                                                time.Sleep(time.Duration(1+r*2) * time.Second)
                                                continue</span>
                                        }
                                }
                                <span class="cov8" title="1">logger.Log.Info("error get updated metric", zap.Error(err))
                                http.Error(res, "error get updated metric", http.StatusInternalServerError)
                                return</span>
                        }
                        <span class="cov8" title="1">metrics[i] = *updated
                        break</span>
                }
        }
        <span class="cov8" title="1">res.Header().Set("Content-Type", "application/json")
        enc := json.NewEncoder(res)
        if err := enc.Encode(metrics); err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error encoding response", zap.Error(err))
                http.Error(res, "error encoding response", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">res.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package router

import (
        "context"
        "database/sql"
        "errors"
        "os"
        "time"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        "github.com/golang-migrate/migrate/v4/source/iofs"
        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/config"
        "github.com/Vidkin/metrics/internal/logger"
        me "github.com/Vidkin/metrics/internal/metric"
        "github.com/Vidkin/metrics/internal/repository/storage"
)

func NewMemoryStorage() *storage.MemoryStorage <span class="cov8" title="1">{
        var m storage.MemoryStorage
        m.Gauge = make(map[string]float64)
        m.Counter = make(map[string]int64)
        m.GaugeMetrics = make([]*me.Metric, 0)
        m.CounterMetrics = make([]*me.Metric, 0)
        m.AllMetrics = make([]*me.Metric, 0)
        return &amp;m
}</span>

func NewFileStorage(fileStoragePath string) *storage.FileStorage <span class="cov8" title="1">{
        var f storage.FileStorage
        f.Gauge = make(map[string]float64)
        f.Counter = make(map[string]int64)
        f.GaugeMetrics = make([]*me.Metric, 0)
        f.CounterMetrics = make([]*me.Metric, 0)
        f.AllMetrics = make([]*me.Metric, 0)
        f.FileStoragePath = fileStoragePath
        return &amp;f
}</span>

func NewPostgresStorage(dbDSN string) (*storage.PostgresStorage, error) <span class="cov8" title="1">{
        var p storage.PostgresStorage
        p.GaugeMetrics = make([]*me.Metric, 0)
        p.CounterMetrics = make([]*me.Metric, 0)
        p.AllMetrics = make([]*me.Metric, 0)

        db, err := sql.Open("pgx", dbDSN)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("error open sql connection", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov8" title="1">{
                logger.Log.Error("can't create postgres driver for migrations", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">d, err := iofs.New(storage.Migrations, "migrations")
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("can't get migrations from FS", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">m, err := migrate.NewWithInstance("iofs", d, "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("can't create new migrate instance", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                logger.Log.Error("can't exec migrations", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">p.Conn = db
        return &amp;p, nil</span>
}

func NewRepository(cfg *config.ServerConfig) (Repository, error) <span class="cov8" title="1">{
        if cfg.DatabaseDSN != "" </span><span class="cov8" title="1">{
                return NewPostgresStorage(cfg.DatabaseDSN)
        }</span>

        <span class="cov8" title="1">if cfg.FileStoragePath != "" </span><span class="cov8" title="1">{
                fileStorage := NewFileStorage(cfg.FileStoragePath)
                if cfg.Restore </span><span class="cov8" title="1">{
                        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
                        defer cancel()

                        for i := 0; i &lt;= cfg.RetryCount; i++ </span><span class="cov8" title="1">{
                                err := fileStorage.Load(ctx)
                                if err != nil </span><span class="cov8" title="1">{
                                        var pathErr *os.PathError
                                        if errors.As(err, &amp;pathErr) &amp;&amp; i != cfg.RetryCount </span><span class="cov0" title="0">{
                                                logger.Log.Info("repository connection error", zap.Error(err))
                                                time.Sleep(time.Duration(1+i*2) * time.Second)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">logger.Log.Info("error load saved metrics", zap.Error(err))</span>
                                }
                                <span class="cov8" title="1">break</span>
                        }
                }
                <span class="cov8" title="1">return fileStorage, nil</span>
        }

        <span class="cov8" title="1">memStorage := NewMemoryStorage()
        return memStorage, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Package cert provides functionality for creating and saving
X.509 certificates and corresponding private keys in PEM format.
*/
package cert

import (
        "bytes"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "math/big"
        "net"
        "os"
        "time"
)

// saveFile saves data to a file at the specified path.
// Parameters:
//   - path: the path to the file where data will be saved.
//   - data: the data to be saved.
//
// Returns an error if the saving fails.
func saveFile(path string, data []byte) error <span class="cov8" title="1">{
        return os.WriteFile(path, data, 0755)
}</span>

// createX509Certificate creates a new X.509 certificate and the corresponding
// private RSA key. The certificate will be valid for the IP addresses
// 127.0.0.1 and ::1, and will have a validity period of 10 years.
// Parameters:
//   - organization: the name of the organization for which the certificate is created.
//   - country: the country where the organization is registered.
//
// Returns the private key, certificate bytes, and an error if the certificate creation fails.
func createX509Certificate(organization, country string) (*rsa.PrivateKey, []byte, error) <span class="cov8" title="1">{
        // создаём шаблон сертификата
        cert := &amp;x509.Certificate{
                // указываем уникальный номер сертификата
                SerialNumber: big.NewInt(1),
                // заполняем базовую информацию о владельце сертификата
                Subject: pkix.Name{
                        Organization: []string{organization},
                        Country:      []string{country},
                },
                // разрешаем использование сертификата для 127.0.0.1 и ::1
                IPAddresses: []net.IP{net.IPv4(127, 0, 0, 1), net.IPv6loopback},
                // сертификат верен, начиная со времени создания
                NotBefore: time.Now(),
                // время жизни сертификата — 10 лет
                NotAfter:     time.Now().AddDate(10, 0, 0),
                SubjectKeyId: []byte{1, 2, 3, 4, 6},
                // устанавливаем использование ключа для цифровой подписи,
                // а также клиентской и серверной авторизации
                ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
                KeyUsage:    x509.KeyUsageDigitalSignature,
        }

        // создаём новый приватный RSA-ключ длиной 4096 бит
        // обратите внимание, что для генерации ключа и сертификата
        // используется rand.Reader в качестве источника случайных данных
        privateKey, err := rsa.GenerateKey(rand.Reader, 4096)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // создаём сертификат x.509
        <span class="cov8" title="1">certBytes, err := x509.CreateCertificate(rand.Reader, cert, cert, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return privateKey, certBytes, nil</span>
}

// createCertPEM encodes the certificate in PEM format.
// Parameters:
//   - certBytes: the bytes of the certificate to encode.
//
// Returns a buffer with the encoded certificate and an error if encoding fails.
func createCertPEM(certBytes []byte) (bytes.Buffer, error) <span class="cov8" title="1">{
        // кодируем сертификат и ключ в формате PEM, который
        // используется для хранения и обмена криптографическими ключами
        var certPEM bytes.Buffer
        err := pem.Encode(&amp;certPEM, &amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: certBytes,
        })
        return certPEM, err
}</span>

// createPrivateKeyPEM encodes the private key in PEM format.
// Parameters:
//   - privateKey: the private RSA key to encode.
//
// Returns a buffer with the encoded private key and an error if encoding fails.
func createPrivateKeyPEM(privateKey *rsa.PrivateKey) (bytes.Buffer, error) <span class="cov8" title="1">{
        var privateKeyPEM bytes.Buffer
        err := pem.Encode(&amp;privateKeyPEM, &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        })
        return privateKeyPEM, err
}</span>

// createAndSave is the entry point of the program. It creates an X.509 certificate,
// generates the corresponding private key, and saves them to files
// cert.pem and privateKey.pem.
// Parameters:
//   - organization: the name of the organization for which the certificate is created.
//   - country: the country where the organization is registered.
//   - pathCertPEM: path where to save cert pem file.
//   - pathPrivateKeyPEM: path where to save private key pem file.
//
// Returns an error if operation fails.
func createAndSave(organization, country, pathCertPEM, pathPrivateKeyPEM string) error <span class="cov8" title="1">{
        privateKey, certBytes, err := createX509Certificate(organization, country)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">certPEM, err := createCertPEM(certBytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">privateKeyPEM, err := createPrivateKeyPEM(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = saveFile(pathCertPEM, certPEM.Bytes())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = saveFile(pathPrivateKeyPEM, privateKeyPEM.Bytes())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package compress provides a Reader and Writer for gzip-compressed data.
// When writing a response, it automatically adds header “Content-Encoding”: “gzip”.
package compress

import (
        "compress/gzip"
        "io"
        "net/http"

        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/logger"
)

// Writer is a wrapper over http.ResponseWriter,
// which adds support for data compression using gzip.
type Writer struct {
        w  http.ResponseWriter
        zw *gzip.Writer
}

// NewCompressWriter creates a new instance of Writer,
// initializing it with the given http.ResponseWriter.
// This constructor also creates a new gzip.Writer,
// which will be used to compress the data before sending it.
//
// Parameters:
// - w: the http.ResponseWriter that will be used to send the compressed data.
//
// Returns:
// - Pointer to a new Writer ready to be used.
func NewCompressWriter(w http.ResponseWriter) *Writer <span class="cov8" title="1">{
        return &amp;Writer{
                w:  w,
                zw: gzip.NewWriter(w),
        }
}</span>

// Header returns the header map that will be sent by the ResponseWriter.
// It allows setting HTTP headers before writing the response.
func (c *Writer) Header() http.Header <span class="cov8" title="1">{
        return c.w.Header()
}</span>

// Write writes the compressed data to the underlying ResponseWriter.
// It sets the "Content-Encoding" header to "gzip" before writing the data.
//
// Parameters:
// - p: a byte slice containing the data to be written.
//
// Returns:
// - The number of bytes written and any error encountered.
func (c *Writer) Write(p []byte) (int, error) <span class="cov8" title="1">{
        c.w.Header().Set("Content-Encoding", "gzip")
        return c.zw.Write(p)
}</span>

// WriteHeader sends an HTTP response header with the provided status code.
// It allows setting the status code for the response.
func (c *Writer) WriteHeader(statusCode int) <span class="cov8" title="1">{
        c.w.WriteHeader(statusCode)
}</span>

// Close closes the gzip.Writer, flushing any buffered data to the underlying writer.
// It should be called to ensure all data is sent before the response is completed.
func (c *Writer) Close() error <span class="cov8" title="1">{
        return c.zw.Close()
}</span>

// Reader is a wrapper over io.ReadCloser,
// which adds support for reading gzip-compressed data.
type Reader struct {
        r  io.ReadCloser
        zr *gzip.Reader
}

// NewCompressReader creates a new instance of Reader,
// initializing it with the given io.ReadCloser.
// This constructor also creates a new gzip.Reader,
// which will be used to decompress the data being read.
//
// Parameters:
// - r: the io.ReadCloser that will be used to read the compressed data.
//
// Returns:
// - Pointer to a new Reader ready to be used, or an error if initialization fails.
func NewCompressReader(r io.ReadCloser) (*Reader, error) <span class="cov8" title="1">{
        zr, err := gzip.NewReader(r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Info("error init compress reader", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Reader{
                r:  r,
                zr: zr,
        }, nil</span>
}

// Read reads the decompressed data from the gzip.Reader into the provided byte slice.
//
// Parameters:
// - p: a byte slice to hold the read data.
//
// Returns:
// - The number of bytes read and any error encountered.
func (c Reader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return c.zr.Read(p)
}</span>

// Close closes the gzip.Reader and the underlying ReadCloser.
// It should be called to release resources associated with the reader.
func (c *Reader) Close() error <span class="cov8" title="1">{
        if err := c.r.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.zr.Close()</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package exitcheck provides an analyzer that checks for the usage of
// os.Exit in the main function of the main package.
package exitcheck

import (
        "go/ast"

        "golang.org/x/tools/go/analysis"
)

// ExitMainAnalyzer is an analyzer that checks for the usage of
// os.Exit in the main function of the main package.
var ExitMainAnalyzer = &amp;analysis.Analyzer{
        Name: "exitmain",
        Doc:  "check for os.Exit in main.Main",
        Run:  run,
}

// run is the main analysis function for the ExitMainAnalyzer.
// It inspects the abstract syntax tree (AST) of Go source files
// to identify calls to os.Exit within the main function of the
// main package.
// Parameters:
//   - pass: An analysis.Pass that contains the files to be analyzed
//     and provides methods for reporting issues.
//
// Returns:
//   - An interface{} (always nil in this case) and an error (always nil).
func run(pass *analysis.Pass) (interface{}, error) <span class="cov8" title="1">{
        for _, f := range pass.Files </span><span class="cov8" title="1">{
                if f.Name.Name == "main" </span><span class="cov8" title="1">{
                        ast.Inspect(f, func(n ast.Node) bool </span><span class="cov8" title="1">{
                                switch x := n.(type) </span>{
                                case *ast.FuncDecl:<span class="cov8" title="1">
                                        if x.Name.Name == "main" </span><span class="cov8" title="1">{
                                                for _, v := range x.Body.List </span><span class="cov8" title="1">{
                                                        if ex, ok := v.(*ast.ExprStmt); ok </span><span class="cov8" title="1">{
                                                                if call, ok := ex.X.(*ast.CallExpr); ok </span><span class="cov8" title="1">{
                                                                        if sl, ok := call.Fun.(*ast.SelectorExpr); ok </span><span class="cov8" title="1">{
                                                                                if id, ok := sl.X.(*ast.Ident); ok </span><span class="cov8" title="1">{
                                                                                        if id.Name == "os" &amp;&amp; sl.Sel.Name == "Exit" </span><span class="cov8" title="1">{
                                                                                                pass.Reportf(x.Pos(), "exit in main func of main package")
                                                                                        }</span>
                                                                                }
                                                                        }
                                                                }
                                                        }
                                                }

                                        }
                                }
                                <span class="cov8" title="1">return true</span>
                        })
                }
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package hash provides utilities for generating cryptographic hashes.
//
// This package includes functions to compute SHA-256 hashes, which can be used for
// data integrity verification, digital signatures, and other security-related tasks.
package hash

import "crypto/sha256"

// GetHashSHA256 computes the SHA-256 hash of the provided data combined with the specified key.
//
// Parameters:
//   - key: A string that acts as a key in the hashing process. It is appended to the
//     data before hashing, adding an additional layer of security and uniqueness to
//     the resulting hash output.
//   - data: A byte slice containing the data to be hashed. This is the main input
//     that will be combined with the key to generate the hash.
//
// Returns:
//   - A byte slice containing the SHA-256 hash of the concatenated data and key.
//     The length of the returned slice is always 32 bytes, as SHA-256 produces a
//     fixed-size output.
func GetHashSHA256(key string, data []byte) []byte <span class="cov8" title="1">{
        h := sha256.New()
        h.Write(data)
        h.Write([]byte(key))
        return h.Sum(nil)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package interceptors

import (
        "bytes"
        "context"
        "encoding/base64"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"

        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/pkg/hash"
)

func HashInterceptor(key string) func(context.Context, interface{}, *grpc.UnaryServerInfo, grpc.UnaryHandler) (interface{}, error) <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="1">{
                if key == "" </span><span class="cov8" title="1">{
                        return handler(ctx, req)
                }</span>

                <span class="cov8" title="1">var hEnc string
                if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov8" title="1">{
                        values := md.Get("HashSHA256")
                        if len(values) &gt; 0 </span><span class="cov8" title="1">{
                                hEnc = values[0]
                        }</span>
                }
                <span class="cov8" title="1">if len(hEnc) == 0 </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.InvalidArgument, "missing hash")
                }</span>

                <span class="cov8" title="1">hashA, err := base64.StdEncoding.DecodeString(hEnc)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error decode hash from base64 string", zap.Error(err))
                        return nil, status.Error(codes.Internal, "missing hash")
                }</span>

                <span class="cov8" title="1">var data []byte
                if msg, ok := req.(proto.Message); ok </span><span class="cov8" title="1">{
                        data, err = proto.Marshal(msg)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("failed to marshal request: %v", zap.Error(err))
                                return nil, status.Errorf(codes.Internal, "failed to marshal request")
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, status.Errorf(codes.Internal, "failed to get proto.Message")
                }</span>

                <span class="cov8" title="1">hashB := hash.GetHashSHA256(key, data)
                if !bytes.Equal(hashA, hashB) </span><span class="cov8" title="1">{
                        logger.Log.Error("hashes don't match")
                        return nil, status.Errorf(codes.InvalidArgument, "hashes don't match")
                }</span>

                <span class="cov8" title="1">return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package interceptors

import (
        "context"
        "time"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/metrics/internal/logger"
)

func LoggingInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) <span class="cov8" title="1">{
        startTime := time.Now()
        itf, err := handler(ctx, req)
        duration := time.Since(startTime)

        var respStatus string
        if err != nil </span><span class="cov8" title="1">{
                st, ok := status.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        respStatus = st.Code().String()
                }</span> else<span class="cov0" title="0"> {
                        respStatus = err.Error()
                }</span>
        } else<span class="cov8" title="1"> {
                respStatus = codes.OK.String()
        }</span>
        <span class="cov8" title="1">logger.Log.Info(
                "Request data",
                zap.String("method", info.FullMethod),
                zap.Duration("duration", duration),
        )
        logger.Log.Info(
                "Response data",
                zap.String("status", respStatus),
        )
        return itf, err</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package interceptors

import (
        "context"
        "net"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/peer"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/metrics/internal/logger"
)

func TrustedSubnetInterceptor(subnet string) func(context.Context, interface{}, *grpc.UnaryServerInfo, grpc.UnaryHandler) (interface{}, error) <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="1">{
                if subnet == "" </span><span class="cov8" title="1">{
                        return handler(ctx, req)
                }</span>

                <span class="cov8" title="1">_, IPNet, err := net.ParseCIDR(subnet)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Log.Error("error parse subnet")
                        return nil, status.Error(codes.PermissionDenied, "error parse subnet")
                }</span>
                <span class="cov8" title="1">var ipStr string
                if p, ok := peer.FromContext(ctx); ok </span><span class="cov8" title="1">{
                        if addr, ok := p.Addr.(*net.TCPAddr); ok </span><span class="cov8" title="1">{
                                ipStr = addr.IP.String()
                        }</span> else<span class="cov0" title="0"> {
                                logger.Log.Error("error get client ip address")
                                return nil, status.Error(codes.PermissionDenied, "error get client ip address")
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Log.Error("error get client ip address")
                        return nil, status.Error(codes.PermissionDenied, "error get client ip address")
                }</span>

                <span class="cov8" title="1">ip := net.ParseIP(ipStr)
                if ip == nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error parse ip")
                        return nil, status.Error(codes.PermissionDenied, "error parse ip")
                }</span>
                <span class="cov8" title="1">if IPNet.Contains(ip) </span><span class="cov8" title="1">{
                        return handler(ctx, req)
                }</span>
                <span class="cov8" title="1">logger.Log.Error("error check trusted subnet")
                return nil, status.Error(codes.PermissionDenied, "error check trusted subnet")</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package ip provides utilities for retrieving network interface information.
//
// This package includes functions to get the IP addresses of all active network
// interfaces on the local machine. It can be useful for applications that need
// to determine the local IP addresses for networking purposes, such as
// server applications or network diagnostics.
package ip

import (
        "net"

        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/logger"
)

// GetMyInterfaces retrieves the IP addresses of all active network interfaces.
//
// This function scans all network interfaces on the local machine and returns
// a slice of strings containing the IPv4 addresses of those interfaces that are
// currently up (active).
//
// Returns:
//   - A slice of strings containing the IPv4 addresses of active network interfaces.
//   - An error if there was an issue retrieving the interfaces or their addresses.
//
// If an error occurs while fetching the interfaces or their addresses, it logs
// the error using the logger package and returns the error to the caller.
func GetMyInterfaces() ([]string, error) <span class="cov8" title="1">{
        interfaces, err := net.Interfaces()
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error getting interfaces", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">res := make([]string, 0, len(interfaces))
        for _, iface := range interfaces </span><span class="cov8" title="1">{
                if iface.Flags&amp;net.FlagUp == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">addrs, err := iface.Addrs()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error getting addresses", zap.Error(err))
                        return nil, err
                }</span>

                <span class="cov8" title="1">for _, addr := range addrs </span><span class="cov8" title="1">{
                        if ipnet, ok := addr.(*net.IPNet); ok &amp;&amp; ipnet.IP.To4() != nil </span><span class="cov8" title="1">{
                                res = append(res, ipnet.IP.String())
                        }</span>
                }
        }
        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/pkg/compress"
)

// Gzip is an HTTP middleware function that enables gzip compression for responses
// and handles gzip decompression for incoming request bodies.
//
// Parameters:
//   - h: An http.Handler that will be wrapped by the Gzip middleware. This is the
//     handler that will process the request after any necessary compression or
//     decompression has been applied.
//
// Returns:
//   - An http.Handler that applies gzip compression for responses and decompression
//     for request bodies, delegating the actual request processing to the provided
//     handler.
func Gzip(h http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ow := w
                acceptEncoding := r.Header.Get("Accept-Encoding")
                if strings.Contains(acceptEncoding, "gzip") </span><span class="cov8" title="1">{
                        cw := compress.NewCompressWriter(w)
                        ow = cw
                        defer func() </span><span class="cov8" title="1">{
                                if err := cw.Close(); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error close compress writer", zap.Error(err))
                                }</span>
                        }()
                }

                <span class="cov8" title="1">contentEncoding := r.Header.Get("Content-Encoding")
                if strings.Contains(contentEncoding, "gzip") </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if err := r.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error close body", zap.Error(err))
                                }</span>
                        }()

                        <span class="cov8" title="1">cr, err := compress.NewCompressReader(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("error init compress reader", zap.Error(err))
                                ow.WriteHeader(http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov8" title="1">r.Body = cr
                        defer func() </span><span class="cov8" title="1">{
                                if err := cr.Close(); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error close compress reader", zap.Error(err))
                                }</span>
                        }()
                }

                <span class="cov8" title="1">h.ServeHTTP(ow, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package middleware

import (
        "bytes"
        "encoding/base64"
        "io"
        "net/http"

        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/logger"
        "github.com/Vidkin/metrics/pkg/hash"
)

type hashResponseWriter struct {
        http.ResponseWriter
        Key        string
        HashSHA256 string
}

// Hash is an HTTP middleware function that validates the integrity of incoming
// request bodies using SHA-256 hashes.
//
// Parameters:
//   - key: A string that serves as a key in the hash computation. This key is
//     used to generate the SHA-256 hash of the request body.
//
// Returns:
//   - A function that takes an http.Handler and returns a new http.Handler
//     that includes the hash validation logic.
func Hash(key string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        hEnc := r.Header.Get("HashSHA256")
                        if hEnc == "" </span><span class="cov8" title="1">{
                                logger.Log.Error("client does not provide any hash")
                                w.WriteHeader(http.StatusBadRequest)
                                return
                        }</span> else<span class="cov8" title="1"> {
                                hashA, err := base64.StdEncoding.DecodeString(hEnc)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error decode hash from base64 string", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return
                                }</span>

                                <span class="cov8" title="1">var buf bytes.Buffer
                                tee := io.TeeReader(r.Body, &amp;buf)

                                defer func() </span><span class="cov8" title="1">{
                                        if err = r.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Error("error close reader body", zap.Error(err))
                                        }</span>
                                }()

                                <span class="cov8" title="1">body, err := io.ReadAll(tee)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error read request body", zap.Error(err))
                                        w.WriteHeader(http.StatusInternalServerError)
                                        return
                                }</span>

                                <span class="cov8" title="1">hashB := hash.GetHashSHA256(key, body)
                                if !bytes.Equal(hashA, hashB) </span><span class="cov8" title="1">{
                                        logger.Log.Error("hashes don't match")
                                        w.WriteHeader(http.StatusBadRequest)
                                        return
                                }</span>

                                <span class="cov8" title="1">r.Body = io.NopCloser(&amp;buf)
                                defer func() </span><span class="cov8" title="1">{
                                        if err := r.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                                logger.Log.Error("error close reader body", zap.Error(err))
                                        }</span>
                                }()
                        }

                        <span class="cov8" title="1">hashRW := hashResponseWriter{
                                ResponseWriter: w,
                                Key:            key,
                        }
                        next.ServeHTTP(hashRW, r)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package middleware

import (
        "net/http"
        "time"

        "go.uber.org/zap"

        "github.com/Vidkin/metrics/internal/logger"
)

type (
        loggingResponseData struct {
                status int
                size   int
        }

        loggingResponseWriter struct {
                http.ResponseWriter
                responseData *loggingResponseData
        }
)

// Write writes the data to the underlying ResponseWriter and updates the size
// of the response. It overrides the default Write method to keep track of the
// total size of the response body.
//
// Parameters:
// - data: A byte slice containing the data to be written to the response.
//
// Returns:
// - The number of bytes written and any error encountered during the write operation.
func (rw *loggingResponseWriter) Write(data []byte) (int, error) <span class="cov8" title="1">{
        size, err := rw.ResponseWriter.Write(data)
        rw.responseData.size += size
        return size, err
}</span>

// WriteHeader sends an HTTP response header with the provided status code.
// It overrides the default WriteHeader method to record the status code
// of the response.
//
// Parameters:
//   - statusCode: An integer representing the HTTP status code to be sent
//     in the response.
func (rw *loggingResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        rw.ResponseWriter.WriteHeader(statusCode)
        rw.responseData.status = statusCode
}</span>

// Logging is an HTTP middleware function that logs details about incoming
// requests and outgoing responses.
//
// This function wraps the provided HTTP handler and logs the HTTP method,
// request URI, response status code, response size, and the duration of
// the request processing. It uses a custom loggingResponseWriter to capture
// the response data.
//
// Parameters:
// - h: An http.Handler that will be wrapped by the Logging middleware.
//
// Returns:
//   - An http.Handler that includes the logging functionality for requests
//     and responses.
func Logging(h http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                startTime := time.Now()
                rData := &amp;loggingResponseData{
                        status: 0,
                        size:   0,
                }
                loggingRW := loggingResponseWriter{
                        responseData:   rData,
                        ResponseWriter: rw,
                }
                h.ServeHTTP(&amp;loggingRW, req)
                duration := time.Since(startTime)

                logger.Log.Info(
                        "Request data",
                        zap.String("method", req.Method),
                        zap.String("URI", req.RequestURI),
                        zap.Duration("duration", duration),
                )

                logger.Log.Info(
                        "Response data",
                        zap.Int("status", rData.status),
                        zap.Int("size", rData.size),
                )
        }</span>)
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package middleware

import (
        "net"
        "net/http"

        "github.com/Vidkin/metrics/internal/logger"
)

// TrustedSubnet is an HTTP middleware function that restricts access to
// incoming requests based on the client's IP address, allowing only
// requests from a specified subnet.
//
// Parameters:
//   - subnet: A string representing the CIDR notation of the trusted subnet.
//     Only clients with IP addresses within this subnet will be allowed to
//     access the next handler in the chain.
//
// Returns:
//   - A function that takes an http.Handler and returns a new http.Handler
//     that includes the subnet validation logic.
func TrustedSubnet(subnet string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        _, IPNet, err := net.ParseCIDR(subnet)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error parse subnet")
                                w.WriteHeader(http.StatusForbidden)
                                return
                        }</span>
                        <span class="cov8" title="1">ipStr := r.Header.Get("X-Real-IP")
                        ip := net.ParseIP(ipStr)
                        if ip == nil </span><span class="cov8" title="1">{
                                logger.Log.Error("error parse ip")
                                w.WriteHeader(http.StatusForbidden)
                                return
                        }</span>
                        <span class="cov8" title="1">if IPNet.Contains(ip) </span><span class="cov8" title="1">{
                                next.ServeHTTP(w, r)
                        }</span>
                        <span class="cov8" title="1">logger.Log.Error("error check trusted subnet")
                        w.WriteHeader(http.StatusForbidden)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.1
//         protoc        v5.28.3
// source: proto/metrics.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Metric_MetricType int32

const (
        Metric_UNSPECIFIED Metric_MetricType = 0
        Metric_COUNTER     Metric_MetricType = 1
        Metric_GAUGE       Metric_MetricType = 2
)

// Enum value maps for Metric_MetricType.
var (
        Metric_MetricType_name = map[int32]string{
                0: "UNSPECIFIED",
                1: "COUNTER",
                2: "GAUGE",
        }
        Metric_MetricType_value = map[string]int32{
                "UNSPECIFIED": 0,
                "COUNTER":     1,
                "GAUGE":       2,
        }
)

func (x Metric_MetricType) Enum() *Metric_MetricType <span class="cov0" title="0">{
        p := new(Metric_MetricType)
        *p = x
        return p
}</span>

func (x Metric_MetricType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Metric_MetricType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_proto_metrics_proto_enumTypes[0].Descriptor()
}</span>

func (Metric_MetricType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_proto_metrics_proto_enumTypes[0]
}</span>

func (x Metric_MetricType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Metric_MetricType.Descriptor instead.
func (Metric_MetricType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{0, 0}
}</span>

type Metric struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Delta int64             `protobuf:"varint,1,opt,name=delta,proto3" json:"delta,omitempty"`
        Value float64           `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
        Id    string            `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
        Type  Metric_MetricType `protobuf:"varint,4,opt,name=type,proto3,enum=metrics.Metric_MetricType" json:"type,omitempty"`
}

func (x *Metric) Reset() <span class="cov0" title="0">{
        *x = Metric{}
        mi := &amp;file_proto_metrics_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Metric) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Metric) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Metric) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_proto_metrics_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Metric.ProtoReflect.Descriptor instead.
func (*Metric) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Metric) GetDelta() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Delta
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Metric) GetValue() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Metric) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Metric) GetType() Metric_MetricType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return Metric_UNSPECIFIED</span>
}

type UpdateMetricsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Metrics []*Metric `protobuf:"bytes,1,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (x *UpdateMetricsRequest) Reset() <span class="cov8" title="1">{
        *x = UpdateMetricsRequest{}
        mi := &amp;file_proto_metrics_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateMetricsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateMetricsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateMetricsRequest) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_proto_metrics_proto_msgTypes[1]
        if x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateMetricsRequest.ProtoReflect.Descriptor instead.
func (*UpdateMetricsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{1}
}</span>

func (x *UpdateMetricsRequest) GetMetrics() []*Metric <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metrics
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateMetricsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Metrics []*Metric `protobuf:"bytes,1,rep,name=metrics,proto3" json:"metrics,omitempty"`
}

func (x *UpdateMetricsResponse) Reset() <span class="cov8" title="1">{
        *x = UpdateMetricsResponse{}
        mi := &amp;file_proto_metrics_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateMetricsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateMetricsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateMetricsResponse) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_proto_metrics_proto_msgTypes[2]
        if x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateMetricsResponse.ProtoReflect.Descriptor instead.
func (*UpdateMetricsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_metrics_proto_rawDescGZIP(), []int{2}
}</span>

func (x *UpdateMetricsResponse) GetMetrics() []*Metric <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metrics
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_proto_metrics_proto protoreflect.FileDescriptor

var file_proto_metrics_proto_rawDesc = []byte{
        0x0a, 0x13, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x22, 0xab,
        0x01, 0x0a, 0x06, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x14, 0x0a, 0x05, 0x64, 0x65, 0x6c,
        0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x12,
        0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x2e, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x4d, 0x65,
        0x74, 0x72, 0x69, 0x63, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x54, 0x79, 0x70, 0x65, 0x52,
        0x04, 0x74, 0x79, 0x70, 0x65, 0x22, 0x35, 0x0a, 0x0a, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x54,
        0x79, 0x70, 0x65, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49,
        0x45, 0x44, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x43, 0x4f, 0x55, 0x4e, 0x54, 0x45, 0x52, 0x10,
        0x01, 0x12, 0x09, 0x0a, 0x05, 0x47, 0x41, 0x55, 0x47, 0x45, 0x10, 0x02, 0x22, 0x41, 0x0a, 0x14,
        0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x29, 0x0a, 0x07, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e,
        0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x52, 0x07, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x22,
        0x42, 0x0a, 0x15, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x29, 0x0a, 0x07, 0x6d, 0x65, 0x74, 0x72,
        0x69, 0x63, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x74, 0x72,
        0x69, 0x63, 0x73, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x52, 0x07, 0x6d, 0x65, 0x74, 0x72,
        0x69, 0x63, 0x73, 0x32, 0x59, 0x0a, 0x07, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x4e,
        0x0a, 0x0d, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12,
        0x1d, 0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e,
        0x2e, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d,
        0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x0f,
        0x5a, 0x0d, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_proto_metrics_proto_rawDescOnce sync.Once
        file_proto_metrics_proto_rawDescData = file_proto_metrics_proto_rawDesc
)

func file_proto_metrics_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_metrics_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_metrics_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_metrics_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_proto_metrics_proto_rawDescData</span>
}

var file_proto_metrics_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_proto_metrics_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_proto_metrics_proto_goTypes = []any{
        (Metric_MetricType)(0),        // 0: metrics.Metric.MetricType
        (*Metric)(nil),                // 1: metrics.Metric
        (*UpdateMetricsRequest)(nil),  // 2: metrics.UpdateMetricsRequest
        (*UpdateMetricsResponse)(nil), // 3: metrics.UpdateMetricsResponse
}
var file_proto_metrics_proto_depIdxs = []int32{
        0, // 0: metrics.Metric.type:type_name -&gt; metrics.Metric.MetricType
        1, // 1: metrics.UpdateMetricsRequest.metrics:type_name -&gt; metrics.Metric
        1, // 2: metrics.UpdateMetricsResponse.metrics:type_name -&gt; metrics.Metric
        2, // 3: metrics.Metrics.UpdateMetrics:input_type -&gt; metrics.UpdateMetricsRequest
        3, // 4: metrics.Metrics.UpdateMetrics:output_type -&gt; metrics.UpdateMetricsResponse
        4, // [4:5] is the sub-list for method output_type
        3, // [3:4] is the sub-list for method input_type
        3, // [3:3] is the sub-list for extension type_name
        3, // [3:3] is the sub-list for extension extendee
        0, // [0:3] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_metrics_proto_init() }</span>
func file_proto_metrics_proto_init() <span class="cov8" title="1">{
        if File_proto_metrics_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_proto_metrics_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_metrics_proto_goTypes,
                DependencyIndexes: file_proto_metrics_proto_depIdxs,
                EnumInfos:         file_proto_metrics_proto_enumTypes,
                MessageInfos:      file_proto_metrics_proto_msgTypes,
        }.Build()
        File_proto_metrics_proto = out.File
        file_proto_metrics_proto_rawDesc = nil
        file_proto_metrics_proto_goTypes = nil
        file_proto_metrics_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: proto/metrics.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Metrics_UpdateMetrics_FullMethodName = "/metrics.Metrics/UpdateMetrics"
)

// MetricsClient is the client API for Metrics service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MetricsClient interface {
        UpdateMetrics(ctx context.Context, in *UpdateMetricsRequest, opts ...grpc.CallOption) (*UpdateMetricsResponse, error)
}

type metricsClient struct {
        cc grpc.ClientConnInterface
}

func NewMetricsClient(cc grpc.ClientConnInterface) MetricsClient <span class="cov8" title="1">{
        return &amp;metricsClient{cc}
}</span>

func (c *metricsClient) UpdateMetrics(ctx context.Context, in *UpdateMetricsRequest, opts ...grpc.CallOption) (*UpdateMetricsResponse, error) <span class="cov8" title="1">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateMetricsResponse)
        err := c.cc.Invoke(ctx, Metrics_UpdateMetrics_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// MetricsServer is the server API for Metrics service.
// All implementations must embed UnimplementedMetricsServer
// for forward compatibility.
type MetricsServer interface {
        UpdateMetrics(context.Context, *UpdateMetricsRequest) (*UpdateMetricsResponse, error)
        mustEmbedUnimplementedMetricsServer()
}

// UnimplementedMetricsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMetricsServer struct{}

func (UnimplementedMetricsServer) UpdateMetrics(context.Context, *UpdateMetricsRequest) (*UpdateMetricsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateMetrics not implemented")
}</span>
func (UnimplementedMetricsServer) mustEmbedUnimplementedMetricsServer() {<span class="cov0" title="0">}</span>
func (UnimplementedMetricsServer) testEmbeddedByValue()                 {<span class="cov8" title="1">}</span>

// UnsafeMetricsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetricsServer will
// result in compilation errors.
type UnsafeMetricsServer interface {
        mustEmbedUnimplementedMetricsServer()
}

func RegisterMetricsServer(s grpc.ServiceRegistrar, srv MetricsServer) <span class="cov8" title="1">{
        // If the following call pancis, it indicates UnimplementedMetricsServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov8" title="1">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov8" title="1">s.RegisterService(&amp;Metrics_ServiceDesc, srv)</span>
}

func _Metrics_UpdateMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(UpdateMetricsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetricsServer).UpdateMetrics(ctx, in)
        }</span>
        <span class="cov8" title="1">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Metrics_UpdateMetrics_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                return srv.(MetricsServer).UpdateMetrics(ctx, req.(*UpdateMetricsRequest))
        }</span>
        <span class="cov8" title="1">return interceptor(ctx, in, info, handler)</span>
}

// Metrics_ServiceDesc is the grpc.ServiceDesc for Metrics service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Metrics_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "metrics.Metrics",
        HandlerType: (*MetricsServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "UpdateMetrics",
                        Handler:    _Metrics_UpdateMetrics_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/metrics.proto",
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
